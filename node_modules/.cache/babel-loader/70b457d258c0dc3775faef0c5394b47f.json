{"ast":null,"code":"/*!\n * Geolocator.js https://github.com/onury/geolocator\n * @license MIT. © 2019, Onur Yıldırım\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define(\"geolocator\", [], factory);else if (typeof exports === 'object') exports[\"geolocator\"] = factory();else root[\"geolocator\"] = factory();\n})(window, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            /******/\n            configurable: false,\n\n            /******/\n            enumerable: true,\n\n            /******/\n            get: getter\n            /******/\n\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // define __esModule on exports\n\n      /******/\n\n\n      __webpack_require__.r = function (exports) {\n        /******/\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"dist/\";\n      /******/\n\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    {\n      /***/\n      \"./src/core/enums.js\":\n      /*!***************************!*\\\n        !*** ./src/core/enums.js ***!\n        \\***************************/\n\n      /*! exports provided: default */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        \"use strict\";\n\n        __webpack_require__.r(__webpack_exports__);\n\n        var GOOGLE_MAPS_API_BASE = '//maps.googleapis.com/maps/api';\n        /**\n         * This file only includes partial documentation about `geolocator` enumerations.\n         * Note that these enumerations are mostly an aggregation of\n         * {@link https://developers.google.com/maps/documentation/javascript|Google Maps API} constants.\n         *\n         * @private\n         * @readonly\n         */\n\n        var enums = Object.freeze({\n          /**\n           * Enumerates API endpoints used within Geolocator core.\n           *\n           * @enum {String}\n           * @readonly\n           * @private\n           */\n          URL: {\n            /**\n             *  Public IP retrieval (free) service.\n             *  @type {String}\n             *  @private\n             */\n            IP: '//api.ipify.org',\n\n            /**\n             *  Country SVG flags.\n             *  e.g. <url>/tr.svg for Turkey flag.\n             *  @type {String}\n             *  @private\n             */\n            FLAG: '//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/',\n\n            /**\n             * Google Maps API bootstrap endpoint that loads all of the main\n             * Javascript objects and symbols for use in the Maps API.\n             * Some Maps API features are also available in self-contained\n             * libraries which are not loaded unless you specifically request them.\n             * See {@link https://developers.google.com/maps/documentation/javascript/libraries|details}.\n             * @type {String}\n             * @private\n             */\n            GOOGLE_MAPS_API: GOOGLE_MAPS_API_BASE + '/js',\n\n            /**\n             * Google Maps API Static Map endpoint.\n             * @type {String}\n             * @private\n             */\n            GOOGLE_SATATIC_MAP: GOOGLE_MAPS_API_BASE + '/staticmap',\n\n            /**\n             * Google Geolocation API endpoint.\n             * @type {String}\n             * @private\n             */\n            GOOGLE_GEOLOCATION: '//www.googleapis.com/geolocation/v1/geolocate',\n\n            /**\n             * Google Geocode API endpoint.\n             * @type {String}\n             * @private\n             */\n            GOOGLE_GEOCODE: '//maps.googleapis.com/maps/api/geocode/json',\n\n            /**\n             * Google TimeZone API endpoint.\n             * @type {String}\n             * @private\n             */\n            GOOGLE_TIMEZONE: '//maps.googleapis.com/maps/api/timezone/json',\n\n            /**\n             * Google Distance Matrix API endpoint.\n             * @type {String}\n             * @private\n             */\n            GOOGLE_DISTANCE_MATRIX: '//maps.googleapis.com/maps/api/distancematrix/json'\n          },\n\n          /**\n           * Enumerates Google map types.\n           * @memberof! geolocator\n           *\n           * @enum {String}\n           * @readonly\n           */\n          MapTypeId: {\n            /**\n             * Map type that displays a transparent layer of major streets on\n             * satellite images.\n             * @type {String}\n             */\n            HYBRID: 'hybrid',\n\n            /**\n             * Map type that displays a normal street map.\n             * @type {String}\n             */\n            ROADMAP: 'roadmap',\n\n            /**\n             * Map type that displays satellite images.\n             * @type {String}\n             */\n            SATELLITE: 'satellite',\n\n            /**\n             * Map type displays maps with physical features such as terrain and\n             * vegetation.\n             * @type {String}\n             */\n            TERRAIN: 'terrain'\n          },\n\n          /**\n           * Enumerates Google location types.\n           * @memberof! geolocator\n           *\n           * @enum {String}\n           * @readonly\n           */\n          LocationType: {\n            /**\n             * Indicates that the returned result is a precise geocode for which\n             * we have location information accurate down to street address\n             * precision.\n             * @type {String}\n             */\n            ROOFTOP: 'ROOFTOP',\n\n            /**\n             * Indicates that the returned result reflects an approximation\n             * (usually on a road) interpolated between two precise points (such as\n             * intersections). Interpolated results are generally returned when\n             * rooftop geocodes are unavailable for a street address.\n             * @type {String}\n             */\n            RANGE_INTERPOLATED: 'RANGE_INTERPOLATED',\n\n            /**\n             * Indicates that the returned result is the geometric center of a\n             * result such as a polyline (for example, a street) or polygon\n             * (region).\n             * @type {String}\n             */\n            GEOMETRIC_CENTER: 'GEOMETRIC_CENTER',\n\n            /**\n             * Indicates that the returned result is approximate.\n             * @type {String}\n             */\n            APPROXIMATE: 'APPROXIMATE'\n          },\n\n          /**\n           * Enumerates Google travel modes.\n           * @memberof! geolocator\n           *\n           * @enum {String}\n           * @readonly\n           */\n          TravelMode: {\n            /**\n             * Indicates distance calculation using the road network.\n             * @type {String}\n             */\n            DRIVING: 'DRIVING',\n\n            /**\n             * Requests distance calculation for walking via pedestrian paths &\n             * sidewalks (where available).\n             * @type {String}\n             */\n            WALKING: 'WALKING',\n\n            /**\n             * Requests distance calculation for bicycling via bicycle paths &\n             * preferred streets (where available).\n             * @type {String}\n             */\n            BICYCLING: 'BICYCLING',\n\n            /**\n             * Requests distance calculation via public transit routes (where\n             * available). This value may only be specified if the request includes\n             * an API key or a Google Maps APIs Premium Plan client ID. If you set\n             * the mode to transit you can optionally specify either a\n             * `departureTime` or an `arrivalTime`. If neither time is specified,\n             * the `departureTime` defaults to now (that is, the departure time defaults\n             * to the current time). You can also optionally include a `transitMode`\n             * and/or a `transitRoutingPreference`.\n             * @type {String}\n             */\n            TRANSIT: 'TRANSIT'\n          },\n          // /**\n          //  * Enumerates Google route restrictions.\n          //  * @memberof! geolocator\n          //  *\n          //  * @enum {String}\n          //  * @readonly\n          //  */\n          // RouteRestriction: {\n          //     TOLLS: 'tolls',\n          //     HIGHWAYS: 'highways',\n          //     FERRIES: 'ferries',\n          //     INDOOR: 'indoor'\n          // },\n\n          /**\n           * Enumerates Google unit systems.\n           * @memberof! geolocator\n           *\n           * @enum {Number}\n           * @readonly\n           */\n          UnitSystem: {\n            /**\n             * Distances in kilometers and meters.\n             * @type {Number}\n             */\n            METRIC: 0,\n\n            /**\n             * Distances defined in miles and feet.\n             * @type {Number}\n             */\n            IMPERIAL: 1\n          },\n\n          /**\n           * Enumerates mobile radio types.\n           * @memberof! geolocator\n           *\n           * @enum {String}\n           * @readonly\n           */\n          RadioType: {\n            /**\n             * LTE (Long-Term Evolution) mobile radio type.\n             * @type {String}\n             */\n            LTE: 'lte',\n\n            /**\n             * GSM (Global System for Mobile Communications) mobile radio type.\n             * @type {String}\n             */\n            GSM: 'gsm',\n\n            /**\n             * CDMA (Code division multiple access) mobile radio access technology.\n             * @type {String}\n             */\n            CDMA: 'cdma',\n\n            /**\n             * Wideband CDMA mobile radio access technology.\n             * @type {String}\n             */\n            WCDMA: 'wcdma'\n          },\n\n          /**\n           * Enumerates formulas/algorithms for calculating the distance between two\n           * lat/lng points.\n           * @memberof! geolocator\n           *\n           * @readonly\n           * @enum {String}\n           *\n           * @todo {@link https://en.wikipedia.org/wiki/Vincenty%27s_formulae|Vincenty's Formula}\n           */\n          DistanceFormula: {\n            /**\n             * Haversine formula for calculating the distance between two lat/lng points\n             * by relating the sides and angles of spherical triangles.\n             * @see {@link http://en.wikipedia.org/wiki/Haversine_formula|Haversine_formula}.\n             * @type {String}\n             */\n            HAVERSINE: 'haversine',\n\n            /**\n             * Formula based on the Pythagoras Theorem for calculating the\n             * distance between two lat/lng points on a Equirectangular projection\n             * to account for curvature of the longitude lines.\n             * @see {@link https://en.wikipedia.org/wiki/Pythagorean_theorem|Pythagorean_theorem}\n             * @type {String}\n             */\n            PYTHAGOREAN: 'pythagorean'\n          },\n\n          /**\n           *  Enumerates the image formats used for getting static Google Map images.\n           *  @memberof! geolocator\n           *\n           *  @readonly\n           *  @enum {String}\n           */\n          ImageFormat: {\n            /**\n             *  Specifies the PNG image format.\n             *  Same as `PNG_8`.\n             *  @type {String}\n             */\n            PNG: 'png',\n\n            /**\n             *  Specifies the 8-bit PNG image format.\n             *  Same as `PNG`.\n             *  @type {String}\n             */\n            PNG_8: 'png8',\n\n            /**\n             *  Specifies the 32-bit PNG image format.\n             *  @type {String}\n             */\n            PNG_32: 'png32',\n\n            /**\n             *  Specifies the GIF image format.\n             *  @type {String}\n             */\n            GIF: 'gif',\n\n            /**\n             *  Specifies the JPEG compressed image format.\n             *  @type {String}\n             */\n            JPG: 'jpg',\n\n            /**\n             *  Specifies a non-progressive JPEG compression image format.\n             *  @type {String}\n             */\n            JPG_BASELINE: 'jpg-baseline'\n          }\n        });\n        /* harmony default export */\n\n        __webpack_exports__[\"default\"] = enums;\n        /***/\n      },\n\n      /***/\n      \"./src/core/geo.error.js\":\n      /*!*******************************!*\\\n        !*** ./src/core/geo.error.js ***!\n        \\*******************************/\n\n      /*! exports provided: default */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        \"use strict\";\n\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony import */\n\n\n        var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n        /*! ../lib/utils */\n        \"./src/lib/utils.js\");\n\n        var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n          return typeof obj;\n        } : function (obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n\n        var _createClass = function () {\n          function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n\n          return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n          };\n        }();\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n        /**\n         * Geolocator Error class that provides a common type of error object for the\n         * various APIs implemented in Geolocator. All callbacks of Geolocator will\n         * include an instance of this object as the first argument; if the\n         * corresponding operation fails. Also all thrown errors will be an instance of\n         * this object.\n         *\n         * This object can be publicly accessed via `geolocator.Error`.\n         *\n         * @extends Error\n         */\n\n\n        var GeoError = function () {\n          // extends Error (doesn't work with transpilers)\n\n          /**\n           * Costructs a new instance of `GeoError`.\n           *\n           * @param {String} [code=\"UNKNOWN_ERROR\"]\n           *        Any valid Geolocator Error code.\n           *        See {@link #GeoError.Code|`GeoError.Code` enumeration} for\n           *        possible values.\n           * @param {String} [message]\n           *        Error message. If omitted, this will be set to `code`.\n           *\n           * @returns {GeoError}\n           *\n           * @example\n           * var GeoError = geolocator.Error,\n           *     error = new GeoError(GeoError.Code.GEOLOCATION_NOT_SUPPORTED);\n           * console.log(error.code); // \"GEOLOCATION_NOT_SUPPORTED\"\n           * console.log(error instanceof GeoError); // true\n           */\n          function GeoError() {\n            var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : GeoError.Code.UNKNOWN_ERROR;\n            var message = arguments[1];\n\n            _classCallCheck(this, GeoError);\n\n            message = message || String(code);\n            /**\n             *  Gets the name of the Error object.\n             *  This always returns `\"GeoError\"`.\n             *  @name GeoError#name\n             *  @type {String}\n             */\n\n            Object.defineProperty(this, 'name', {\n              enumerable: false,\n              writable: false,\n              value: 'GeoError' // this.constructor.name\n\n            });\n            /**\n             *  Gets the error code set for this instance.\n             *  This will return one of\n             *  {@link #GeoError.Code|`GeoError.Code` enumeration}.\n             *  @name GeoError#code\n             *  @type {String}\n             */\n\n            Object.defineProperty(this, 'code', {\n              enumerable: false,\n              writable: true,\n              value: code\n            });\n            /**\n             *  Gets the error message set for this instance.\n             *  If no message is set, this will return the error code value.\n             *  @name GeoError#message\n             *  @type {String}\n             */\n\n            Object.defineProperty(this, 'message', {\n              enumerable: false,\n              writable: true,\n              value: message\n            });\n\n            if (Error.hasOwnProperty('captureStackTrace')) {\n              // V8\n              Error.captureStackTrace(this, this.constructor);\n            } else {\n              /**\n               *  Gets the error stack for this instance.\n               *  @name GeoError#stack\n               *  @type {String}\n               */\n              Object.defineProperty(this, 'stack', {\n                enumerable: false,\n                writable: false,\n                value: new Error(message).stack\n              });\n            }\n          }\n          /**\n           * Creates a new instance of `GeoError` from the given value.\n           *\n           * @param {*} [err]\n           *        Value to be transformed. This is used to determine the proper\n           *        error code for the created instance. If an `Error` or `Object` is\n           *        passed, its `message` property is checked if it matches any of the\n           *        valid error codes. If omitted or no match is found, error code\n           *        `GeoError.Code.UNKNOWN_ERROR` will be used as default.\n           *\n           * @returns {GeoError}\n           *\n           * @example\n           * var GeoError = geolocator.Error,\n           * \t   error = GeoError.create();\n           * console.log(error.code); // \"UNKNOWN_ERROR\"\n           * error = GeoError.create(GeoError.Code.GEOLOCATION_NOT_SUPPORTED);\n           * console.log(error.code); // \"GEOLOCATION_NOT_SUPPORTED\"\n           */\n\n\n          _createClass(GeoError, null, [{\n            key: 'create',\n            value: function create(err) {\n              if (err instanceof GeoError) {\n                return err;\n              }\n\n              var code = void 0,\n                  msg = void 0;\n\n              if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPositionError(err) && err.code) {\n                switch (err.code) {\n                  case 1:\n                    code = GeoError.Code.PERMISSION_DENIED;\n                    break;\n\n                  case 2:\n                    code = GeoError.Code.POSITION_UNAVAILABLE;\n                    break;\n\n                  case 3:\n                    code = GeoError.Code.TIMEOUT;\n                    break;\n\n                  default:\n                    code = GeoError.Code.UNKNOWN_ERROR;\n                    break;\n                }\n\n                return new GeoError(code, err.message || '');\n              }\n\n              if (typeof err === 'string') {\n                code = msg = err;\n              } else if ((typeof err === 'undefined' ? 'undefined' : _typeof(err)) === 'object') {\n                code = err.code || err.message;\n                msg = err.message || err.code;\n              }\n\n              if (code && GeoError.isValidErrorCode(code)) {\n                return new GeoError(code, msg);\n              }\n\n              return new GeoError(GeoError.Code.UNKNOWN_ERROR, msg);\n            }\n            /**\n             * Creates a new instance of `GeoError` from the given response object.\n             * Since Geolocator implements various Google APIs, we might receive\n             * responses if different structures. For example, some APIs return a\n             * response object with a `status:String` property (such as the TimeZone\n             * API) and some return responses with an `error:Object` property. This\n             * method will determine the correct reason or message and return a\n             * consistent error object.\n             *\n             * @param {Object|String} response\n             *        Response (Object) or status (String) to be transformed.\n             * @param {String} [message=null]\n             *        Error message.\n             *\n             * @returns {GeoError}\n             *          `GeoError` instance if response contains an error. Otherwise,\n             *          returns `null`.\n             *\n             * @example\n             * var error = geolocator.Error.fromResponse(googleResponse);\n             * console.log(error.code); // \"GOOGLE_KEY_INVALID\"\n             */\n\n          }, {\n            key: 'fromResponse',\n            value: function fromResponse(response) {\n              var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ''; // example Google Geolocation API response:\n              // https://developers.google.com/maps/documentation/geolocation/intro#errors\n              // {\n              //      \"error\": {\n              //          \"errors\": [\n              //              {\n              //                  \"domain\": \"global\",\n              //                  \"reason\": \"parseError\",\n              //                  \"message\": \"Parse Error\",\n              //              }\n              //          ],\n              //      \"code\": 400,\n              //      \"message\": \"Parse Error\"\n              //      }\n              // }\n              // example Google TimeZone API response:\n              // {\n              //     \"status\": \"REQUEST_DENIED\"\n              // }\n\n              if (!response) return new GeoError(GeoError.Code.INVALID_RESPONSE);\n              var errCode = void 0;\n\n              if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(response)) {\n                errCode = errorCodeFromStatus(response);\n                if (errCode) return new GeoError(errCode, message || response);\n              }\n\n              if (!_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject(response)) return null;\n              var errMsg = response.error_message || response.errorMessage || response.error && response.error.message || '' || '';\n\n              if (response.status) {\n                errCode = errorCodeFromStatus(response.status);\n                if (errCode) return new GeoError(errCode, errMsg || message || response.status);\n              }\n\n              if (response.error) {\n                var reason = response.reason || response.error.reason;\n\n                if (!reason) {\n                  var errors = response.error.errors;\n\n                  if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(errors) && errors.length > 0) {\n                    reason = errors[0].reason; // get the first reason only\n\n                    errMsg = errMsg || errors[0].message; // update errMsg\n                  }\n                }\n\n                errCode = errorCodeFromReason(reason) || GeoError.Code.UNKNOWN_ERROR;\n                return new GeoError(errCode, errMsg || reason || message);\n              }\n\n              if (errMsg) {\n                errCode = errorCodeFromStatus(errMsg) || GeoError.Code.UNKNOWN_ERROR;\n                return new GeoError(errCode, errMsg || message);\n              }\n\n              return null;\n            }\n            /**\n             *  Checks whether the given value is an instance of `GeoError`.\n             *\n             *  @param {*} err - Object to be checked.\n             *\n             *  @returns {Boolean}\n             */\n\n          }, {\n            key: 'isGeoError',\n            value: function isGeoError(err) {\n              return err instanceof GeoError;\n            }\n            /**\n             *  Checks whether the given value is a valid Geolocator Error code.\n             *\n             *  @param {String} errorCode - Error code to be checked.\n             *\n             *  @returns {Boolean}\n             */\n\n          }, {\n            key: 'isValidErrorCode',\n            value: function isValidErrorCode(errorCode) {\n              var prop = void 0;\n\n              for (prop in GeoError.Code) {\n                if (GeoError.Code.hasOwnProperty(prop) && errorCode === GeoError.Code[prop]) {\n                  return true;\n                }\n              }\n\n              return false;\n            }\n          }]);\n\n          return GeoError;\n        }();\n        /**\n         *  Gets the string representation of the error instance.\n         *\n         *  @returns {String}\n         */\n\n\n        GeoError.prototype.toString = function () {\n          var msg = this.code !== this.message ? ' (' + this.message + ')' : '';\n          return this.name + ': ' + this.code + msg;\n        }; // `class x extends Error` doesn't work when using an ES6 transpiler, such as\n        // Babel, since subclasses must extend a class. With Babel 6, we need\n        // transform-builtin-extend plugin for this to work. So we're extending from\n        // Error the old way. Now, `err instanceof Error` also returns `true`.\n\n\n        if (typeof Object.setPrototypeOf === 'function') {\n          Object.setPrototypeOf(GeoError.prototype, Error.prototype);\n        } else {\n          GeoError.prototype = Object.create(Error.prototype);\n        } // ---------------------------\n        // ERROR CODES\n        // ---------------------------\n\n        /**\n         *  Enumerates Geolocator error codes.\n         *  This enumeration combines Google API status (error) codes, HTML5 Geolocation\n         *  position error codes and other Geolocator-specific error codes.\n         *  @enum {String}\n         */\n\n\n        GeoError.Code = {\n          /**\n           *  Indicates that HTML5 Geolocation API is not supported by the browser.\n           *  @type {String}\n           */\n          GEOLOCATION_NOT_SUPPORTED: 'GEOLOCATION_NOT_SUPPORTED',\n\n          /**\n           *  Indicates that Geolocation-IP source is not set or invalid.\n           *  @type {String}\n           */\n          INVALID_GEO_IP_SOURCE: 'INVALID_GEO_IP_SOURCE',\n\n          /**\n           *  The acquisition of the geolocation information failed because the\n           *  page didn't have the permission to do it.\n           *  @type {String}\n           */\n          PERMISSION_DENIED: 'PERMISSION_DENIED',\n\n          /**\n           *  The acquisition of the geolocation failed because at least one\n           *  internal source of position returned an internal error.\n           *  @type {String}\n           */\n          POSITION_UNAVAILABLE: 'POSITION_UNAVAILABLE',\n\n          /**\n           *  The time allowed to acquire the geolocation, defined by\n           *  PositionOptions.timeout information was reached before\n           *  the information was obtained.\n           *  @type {String}\n           */\n          TIMEOUT: 'TIMEOUT',\n\n          /**\n           * Indicates that the request had one or more invalid parameters.\n           * @type {String}\n           */\n          INVALID_PARAMETERS: 'INVALID_PARAMETERS',\n\n          /**\n           * Indicates that the service returned invalid response.\n           * @type {String}\n           */\n          INVALID_RESPONSE: 'INVALID_RESPONSE',\n\n          /**\n           * Generally indicates that the query (address, components or latlng)\n           * is missing.\n           * @type {String}\n           */\n          INVALID_REQUEST: 'INVALID_REQUEST',\n\n          /**\n           * Indicates that the request was denied by the service.\n           * This will generally occur because of a missing API key or because the request\n           * is sent over HTTP instead of HTTPS.\n           * @type {String}\n           */\n          REQUEST_DENIED: 'REQUEST_DENIED',\n\n          /**\n           * Indicates that the request has failed.\n           * This will generally occur because of an XHR error.\n           * @type {String}\n           */\n          REQUEST_FAILED: 'REQUEST_FAILED',\n\n          /**\n           * Indicates that Google API could not be loaded.\n           * @type {String}\n           */\n          GOOGLE_API_FAILED: 'GOOGLE_API_FAILED',\n\n          /**\n           * Indicates that you are over your Google API quota.\n           * @type {String}\n           */\n          OVER_QUERY_LIMIT: 'OVER_QUERY_LIMIT',\n\n          /**\n           * Indicates that you've exceeded the requests per second per user limit that\n           * you configured in the Google Developers Console. This limit should be\n           * configured to prevent a single or small group of users from exhausting your\n           * daily quota, while still allowing reasonable access to all users.\n           * @type {String}\n           */\n          USER_RATE_LIMIT_EXCEEDED: 'USER_RATE_LIMIT_EXCEEDED',\n\n          /**\n           * Indicates that you've exceeded your daily limit for Google API(s).\n           * @type {String}\n           */\n          DAILY_LIMIT_EXCEEDED: 'DAILY_LIMIT_EXCEEDED',\n\n          /**\n           * Indicates that your Google API key is not valid. Please ensure that you've\n           * included the entire key, and that you've either purchased the API or have\n           * enabled billing and activated the API to obtain the free quota.\n           * @type {String}\n           */\n          GOOGLE_KEY_INVALID: 'GOOGLE_KEY_INVALID',\n\n          /**\n           * Indicates that maximum number of elements limit is exceeded. For\n           * example, for the Distance Matrix API; occurs when the product of\n           * origins and destinations exceeds the per-query limit.\n           * @type {String}\n           */\n          MAX_ELEMENTS_EXCEEDED: 'MAX_ELEMENTS_EXCEEDED',\n\n          /**\n           * Indicates that the request contained more than 25 origins,\n           * or more than 25 destinations.\n           * @type {String}\n           */\n          MAX_DIMENSIONS_EXCEEDED: 'MAX_DIMENSIONS_EXCEEDED',\n\n          /**\n           * Indicates that the request contained more than allowed waypoints.\n           * @type {String}\n           */\n          MAX_WAYPOINTS_EXCEEDED: 'MAX_WAYPOINTS_EXCEEDED',\n\n          /**\n           * Indicates that the request body is not valid JSON.\n           * @type {String}\n           */\n          PARSE_ERROR: 'PARSE_ERROR',\n\n          /**\n           * Indicates that the requested resource could not be found.\n           * Note that this also covers `ZERO_RESULTS`.\n           * @type {String}\n           */\n          NOT_FOUND: 'NOT_FOUND',\n\n          /**\n           * Indicates that an internal error (such as XHR cross-domain, etc) has occured.\n           * @type {String}\n           */\n          INTERNAL_ERROR: 'INTERNAL_ERROR',\n\n          /**\n           * Indicates that an unknown error has occured.\n           * @type {String}\n           */\n          UNKNOWN_ERROR: 'UNKNOWN_ERROR'\n        }; // ---------------------------\n        // HELPER METHODS\n        // ---------------------------\n\n        /**\n         *  @private\n         */\n\n        function errorCodeFromStatus(status) {\n          if (!status) return GeoError.Code.INVALID_RESPONSE;\n          if (status === 'OK') return null;\n          if (status === 'ZERO_RESULTS') return GeoError.Code.NOT_FOUND;\n          if (GeoError.Code.hasOwnProperty(status)) return status;\n          return null;\n        }\n        /**\n         *  Gets `GeoError.Code` from the given response error reason.\n         *  @private\n         *\n         *  @param {String} reason\n         *         Google response error reason.\n         *\n         *  @returns {String}\n         */\n\n\n        function errorCodeFromReason(reason) {\n          switch (reason) {\n            case 'invalid':\n              return GeoError.Code.INVALID_REQUEST;\n\n            case 'dailyLimitExceeded':\n              return GeoError.Code.DAILY_LIMIT_EXCEEDED;\n\n            case 'keyInvalid':\n              return GeoError.Code.GOOGLE_KEY_INVALID;\n\n            case 'userRateLimitExceeded':\n              return GeoError.Code.USER_RATE_LIMIT_EXCEEDED;\n\n            case 'notFound':\n              return GeoError.Code.NOT_FOUND;\n\n            case 'parseError':\n              return GeoError.Code.PARSE_ERROR;\n\n            default:\n              return null;\n          }\n        } // ---------------------------\n        // EXPORT\n        // ---------------------------\n\n        /* harmony default export */\n\n\n        __webpack_exports__[\"default\"] = GeoError;\n        /***/\n      },\n\n      /***/\n      \"./src/core/geo.helper.js\":\n      /*!********************************!*\\\n        !*** ./src/core/geo.helper.js ***!\n        \\********************************/\n\n      /*! exports provided: default */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        \"use strict\";\n\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony import */\n\n\n        var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n        /*! ../lib/utils */\n        \"./src/lib/utils.js\");\n        /* harmony import */\n\n\n        var _lib_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n        /*! ../lib/fetch */\n        \"./src/lib/fetch.js\");\n        /* harmony import */\n\n\n        var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\n        /*! ./enums */\n        \"./src/core/enums.js\");\n        /* harmony import */\n\n\n        var _geo_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\n        /*! ./geo.error */\n        \"./src/core/geo.error.js\");\n        /**\n         *  Helper methods.\n         *  @type {Object}\n         *  @private\n         */\n\n\n        var geoHelper = {\n          toGoogleCoords: function toGoogleCoords(coords) {\n            return {\n              lat: coords.lat || coords.latitude,\n              lng: coords.lng || coords.longitude\n            };\n          },\n          fromGoogleCoords: function fromGoogleCoords(coords) {\n            return {\n              latitude: coords.latitude || coords.lat,\n              longitude: coords.longitude || coords.lng\n            };\n          },\n          // used for distance matrix origins and destinations\n          toPointList: function toPointList(arr) {\n            arr = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(arr) ? arr : [arr];\n            return arr.map(function (o) {\n              return _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(o) ? o : geoHelper.toGoogleCoords(o);\n            });\n          },\n          getGeocodeComps: function getGeocodeComps(comp) {\n            return {\n              route: comp.route,\n              locality: comp.locality,\n              administrative_area: comp.administrativeArea,\n              // eslint-disable-line camelcase\n              postal_code: comp.postalCode,\n              // eslint-disable-line camelcase\n              country: comp.country,\n              region: comp.region\n            };\n          },\n          // Geocode examples:\n          // address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&key=API_KEY\n          // address=Winnetka&bounds=34.172684,-118.604794|34.236144,-118.500938&key=API_KEY\n          // address=santa+cruz&components=country:ES&key=API_KEY\n          // components=administrative_area:TX|country:US&key=API_KEY\n          // Reverse Geocode examples:\n          // latlng=40.714224,-73.961452&key=API_KEY\n          // place_id=ChIJd8BlQ2BZwokRAFUEcm_qrcA&key=API_KEY\n          buildGeocodeParams: function buildGeocodeParams(options, reverse) {\n            var params = [],\n                e = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodeURI;\n\n            if (reverse) {\n              if (options.placeId) {\n                params.push('place_id=' + options.placeId);\n              } else if (options.latitude && options.longitude) {\n                params.push('latlng=' + options.latitude + ',' + options.longitude);\n              }\n            } else {\n              if (options.address) {\n                params.push('address=' + e(options.address));\n              }\n\n              var geoComps = geoHelper.getGeocodeComps(options);\n              geoComps = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].params(geoComps, {\n                operator: ':',\n                separator: '|'\n              });\n              params.push('components=' + geoComps);\n              var b = options.bounds;\n\n              if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(b) && b.length === 4) {\n                params.push('bounds=' + b[0] + ',' + b[1] + '|' + b[2] + ',' + b[3]);\n              } else if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(b) && Object.keys(b).length === 4) {\n                params.push('bounds=' + b.southwestLat + ',' + b.southwestLng + '|' + b.northeastLat + ',' + b.northeastLng);\n              }\n            }\n\n            params.push('language=' + options.language);\n            params.push('key=' + options.key);\n            return params.join('&');\n          },\n          // See https://developers.google.com/maps/documentation/geocoding/intro\n          formatGeocodeResults: function formatGeocodeResults(results) {\n            if (!_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(results) || results.length <= 0) {\n              return {\n                location: null,\n                address: null,\n                formattedAddress: '',\n                type: null,\n                // locationType\n                placeId: ''\n              };\n            }\n\n            var i = void 0,\n                c = void 0,\n                o = {},\n                data = results[0],\n                comps = data.address_components;\n\n            for (i = 0; i < comps.length; i += 1) {\n              c = comps[i];\n\n              if (c.types && c.types.length > 0) {\n                o[c.types[0]] = c.long_name;\n                o[c.types[0] + '_s'] = c.short_name;\n              }\n            }\n\n            var geometry = data.geometry;\n            return {\n              coords: geometry && geometry.location ? {\n                latitude: geometry.location.lat,\n                longitude: geometry.location.lng\n              } : null,\n              address: {\n                commonName: o.point_of_interest || o.premise || o.subpremise || o.colloquial_area || '',\n                streetNumber: o.street_number || '',\n                street: o.administrative_area_level_4 || o.administrative_area_level_3 || o.route || '',\n                route: o.route || '',\n                neighborhood: o.neighborhood || o.administrative_area_level_5 || o.administrative_area_level_4 || '',\n                town: o.sublocality || o.administrative_area_level_2 || '',\n                city: o.locality || o.administrative_area_level_1 || '',\n                region: o.administrative_area_level_2 || o.administrative_area_level_1 || '',\n                postalCode: o.postal_code || '',\n                state: o.administrative_area_level_1 || '',\n                stateCode: o.administrative_area_level_1_s || '',\n                country: o.country || '',\n                countryCode: o.country_s || ''\n              },\n              formattedAddress: data.formatted_address,\n              type: geometry.location_type || '',\n              placeId: data.place_id,\n              timestamp: _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].time()\n            };\n          },\n          geocode: function geocode(reverse, conf, options, callback) {\n            var opts = {};\n\n            if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(options)) {\n              opts = {};\n              var prop = reverse ? 'placeId' : 'address';\n              opts[prop] = options;\n            } else if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(options)) {\n              opts = options;\n            } else {\n              throw new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.INVALID_PARAMETERS);\n            }\n\n            if (reverse) {\n              var coordsSet = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber(options.latitude) && _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber(options.longitude);\n\n              if (!_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(options.placeId) && !coordsSet) {\n                throw new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.INVALID_PARAMETERS);\n              }\n            }\n\n            opts = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({\n              key: conf.google.key || '',\n              language: conf.language || 'en',\n              raw: false\n            }, opts);\n\n            var query = geoHelper.buildGeocodeParams(opts, reverse),\n                url = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setProtocol(_enums__WEBPACK_IMPORTED_MODULE_2__[\"default\"].URL.GOOGLE_GEOCODE, conf.https),\n                xhrOpts = {\n              url: url + '?' + query\n            };\n\n            _lib_fetch__WEBPACK_IMPORTED_MODULE_1__[\"default\"].xhr(xhrOpts, function (err, xhr) {\n              if (err) return callback(_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(err), null);\n\n              var response = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].safeJsonParse(xhr.responseText),\n                  gErr = _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromResponse(response);\n\n              if (gErr) return callback(gErr, null);\n              response = options.raw ? response : geoHelper.formatGeocodeResults(response.results);\n              callback(null, response);\n            });\n          },\n          // See https://developers.google.com/maps/documentation/distance-matrix/intro\n          // Raw Result Example:\n          // {\n          //    \"destination_addresses\" : [ \"San Francisco, CA, USA\", \"Victoria, BC, Canada\" ],\n          //    \"origin_addresses\" : [ \"Vancouver, BC, Canada\", \"Seattle, WA, USA\" ],\n          //    \"rows\" : [\n          //       {\n          //          \"elements\" : [\n          //             {\n          //                \"distance\" : { \"text\" : \"1,704 km\", \"value\" : 1704324 },\n          //                \"duration\" : { \"text\" : \"3 days 19 hours\", \"value\" : 327061\n          //                },\n          //                \"status\" : \"OK\"\n          //             },\n          //             {\n          //                \"distance\" : { \"text\" : \"138 km\", \"value\" : 138295 },\n          //                \"duration\" : { \"text\" : \"6 hours 44 mins\", \"value\" : 24236 },\n          //                \"status\" : \"OK\"\n          //             }\n          //          ]\n          //       },\n          //       {\n          //          \"elements\" : [\n          //             {\n          //                \"distance\" : { \"text\" : \"1,452 km\", \"value\" : 1451623 },\n          //                \"duration\" : { \"text\" : \"3 days 4 hours\", \"value\" : 275062 },\n          //                \"status\" : \"OK\"\n          //             },\n          //             {\n          //                \"distance\" : { \"text\" : \"146 km\", \"value\" : 146496 },\n          //                \"duration\" : { \"text\" : \"2 hours 52 mins\", \"value\" : 10324 },\n          //                \"status\" : \"OK\"\n          //             }\n          //          ]\n          //       }\n          //    ],\n          //    \"status\" : \"OK\"\n          // }\n          // Formatted to:\n          formatDistanceResults: function formatDistanceResults(results) {\n            if (!_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(results)) {\n              return null;\n            }\n\n            var arr = [],\n                origins = results.originAddresses,\n                dests = results.destinationAddresses,\n                rows = results.rows; // [\n            //     {\n            //          from: 'Vancouver, BC, Canada',\n            //          to: 'San Francisco, CA, USA',\n            //          distance: { value: 1704107, text: \"1,704 km\" },\n            //          duration: { value: 327025, text: \"3 days 19 hours\" },\n            //          fare: { currency: \"USD\", value: 6, text: \"$6.00\" }\n            //     },\n            //     ...\n            // ]\n\n            var e = void 0;\n            origins.forEach(function (origin, oIndex) {\n              dests.forEach(function (dest, dIndex) {\n                e = rows[oIndex].elements[dIndex];\n                arr.push({\n                  from: origin,\n                  to: dest,\n                  distance: e.distance,\n                  duration: e.duration,\n                  fare: e.fare,\n                  timestamp: _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].time()\n                });\n              });\n            });\n            return arr;\n          },\n          // Converts a map-styles object in to static map styles (formatted query-string params).\n          // See https://developers.google.com/maps/documentation/static-maps/styling\n          mapStylesToParams: function mapStylesToParams(styles) {\n            if (!styles) return '';\n            if (!_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(styles)) styles = [styles];\n            var result = [];\n            styles.forEach(function (v, i, a) {\n              var style = '';\n\n              if (v.stylers) {\n                // only if there is a styler object\n                if (v.stylers.length > 0) {\n                  // Needs to have a style rule to be valid.\n                  style += (v.hasOwnProperty('featureType') ? 'feature:' + v.featureType : 'feature:all') + '|';\n                  style += (v.hasOwnProperty('elementType') ? 'element:' + v.elementType : 'element:all') + '|';\n                  v.stylers.forEach(function (val, i, a) {\n                    var propName = Object.keys(val)[0],\n                        propVal = val[propName].toString().replace('#', '0x');\n                    style += propName + ':' + propVal + '|';\n                  });\n                }\n              }\n\n              result.push('style=' + encodeURIComponent(style));\n            });\n            return result.join('&');\n          }\n        };\n        /* harmony default export */\n\n        __webpack_exports__[\"default\"] = geoHelper;\n        /***/\n      },\n\n      /***/\n      \"./src/core/geo.watcher.js\":\n      /*!*********************************!*\\\n        !*** ./src/core/geo.watcher.js ***!\n        \\*********************************/\n\n      /*! exports provided: default */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        \"use strict\";\n\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony import */\n\n\n        var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n        /*! ../lib/utils */\n        \"./src/lib/utils.js\");\n\n        var _createClass = function () {\n          function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n\n          return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n          };\n        }();\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        var GeoWatcher = function () {\n          function GeoWatcher(onChange, onError) {\n            var _this = this;\n\n            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n            _classCallCheck(this, GeoWatcher);\n\n            this.isCleared = false;\n            this.cycle = 0;\n            this._timer = null;\n            this.id = navigator.geolocation.watchPosition(function (pos) {\n              _this.cycle++;\n              if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFunction(onChange)) onChange(pos);\n            }, function (err) {\n              _this.cycle++;\n              if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFunction(onError)) onError(err);\n\n              if (options.clearOnError) {\n                _this.clear();\n              }\n            }, options);\n          }\n\n          _createClass(GeoWatcher, [{\n            key: '_clear',\n            value: function _clear() {\n              navigator.geolocation.clearWatch(this.id);\n              this.isCleared = true;\n              this._timer = null;\n            }\n          }, {\n            key: 'clear',\n            value: function clear(delay, callback) {\n              var _this2 = this;\n\n              var d = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber(delay) ? delay : 0,\n                  cb = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFunction(callback) ? callback : _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFunction(delay) ? delay : null; // clear any previous timeout\n\n              if (this._timer) {\n                clearTimeout(this._timer);\n                this._timer = null;\n              } // check if watcher is not cleared\n\n\n              if (!this.isCleared) {\n                if (d === 0) {\n                  this._clear();\n\n                  if (cb) cb();\n                  return;\n                }\n\n                this._timer = setTimeout(function () {\n                  _this2._clear();\n\n                  if (cb) cb();\n                }, d);\n              }\n            }\n          }]);\n\n          return GeoWatcher;\n        }(); // ---------------------------\n        // EXPORT\n        // ---------------------------\n\n        /* harmony default export */\n\n\n        __webpack_exports__[\"default\"] = GeoWatcher;\n        /***/\n      },\n\n      /***/\n      \"./src/core/geolocator.js\":\n      /*!********************************!*\\\n        !*** ./src/core/geolocator.js ***!\n        \\********************************/\n\n      /*! exports provided: geolocator */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        \"use strict\";\n\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"geolocator\", function () {\n          return geolocator;\n        });\n        /* harmony import */\n\n\n        var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n        /*! ../lib/utils */\n        \"./src/lib/utils.js\");\n        /* harmony import */\n\n\n        var _lib_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n        /*! ../lib/fetch */\n        \"./src/lib/fetch.js\");\n        /* harmony import */\n\n\n        var _geo_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\n        /*! ./geo.helper */\n        \"./src/core/geo.helper.js\");\n        /* harmony import */\n\n\n        var _geo_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\n        /*! ./geo.error */\n        \"./src/core/geo.error.js\");\n        /* harmony import */\n\n\n        var _geo_watcher__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\n        /*! ./geo.watcher */\n        \"./src/core/geo.watcher.js\");\n        /* harmony import */\n\n\n        var _enums__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\n        /*! ./enums */\n        \"./src/core/enums.js\");\n\n        var _createClass = function () {\n          function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n\n          return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n          };\n        }();\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n        /**\n         *  Radius of earth in kilometers.\n         *  @private\n         *  @type {Number}\n         */\n\n\n        var EARTH_RADIUS_KM = 6371;\n        /**\n         *  Radius of earth in miles.\n         *  @private\n         *  @type {Number}\n         */\n\n        var EARTH_RADIUS_MI = 3959;\n        /**\n         *  Storage for Geolocator default configuration.\n         *\n         *  @readonly\n         *  @private\n         */\n\n        var defaultConfig = {\n          language: 'en',\n          https: true,\n          google: {\n            version: '3',\n            // latest 3.x\n            key: '',\n            styles: null\n          }\n        };\n        /**\n         *  Geolocator library that provides methods for getting geo-location information,\n         *  geocoding, address look-ups, distance & durations, timezone information and more...\n         *  This library makes use of HTML5 position feautures, implements Google APIs\n         *  and other services.\n         *\n         *  <b>Important Notes:</b>\n         *\n         *  Although some calls might work without a key, it is generally required by\n         *  most {@link https://developers.google.com/maps/faq#using-google-maps-apis|Goolge APIs}\n         *  (such as Time Zone API). To get a free (or premium) key,\n         *  {@link https://developers.google.com/maps/documentation/javascript/|click here}.\n         *  After getting a key, you can enable multiple APIs for it. Make sure you\n         *  {@link https://console.developers.google.com|enable}\n         *  all the APIs supported by Geolocator.\n         *\n         *  Note that browser API keys cannot have referer restrictions when used\n         *  with some Google APIs.\n         *\n         *  Make sure your doctype is HTML5 and you're calling Geolocation APIs from an\n         *  HTTPS page. Geolocation API is removed from unsecured origins in Chrome 50.\n         *  Other browsers are expected to follow.\n         *\n         *  @license MIT\n         *  @copyright 2019, Onur Yıldırım <onur@cutepilot.com>\n         */\n\n        var geolocator = function () {\n          function geolocator() {\n            _classCallCheck(this, geolocator);\n          }\n\n          _createClass(geolocator, null, [{\n            key: 'config',\n            // ---------------------------\n            // STATIC METHODS\n            // ---------------------------\n\n            /**\n             *  Sets or gets the geolocator configuration object.\n             *  Make sure you configure Geolocator before calling other methods that\n             *  require a Google API key.\n             *\n             *  @param {Object} [options]\n             *         Configuration object. If omitted, this method returns the current\n             *         configuration.\n             *      @param {String} [options.language=\"en\"]\n             *             Language to be used for API requests that supports language\n             *             configurations. This is generally used for Google APIs.\n             *             See {@link https://developers.google.com/maps/faq#languagesupport|supported languages}.\n             *      @param {Boolean} [options.https=true]\n             *             As Google recommends; using HTTPS encryption makes your site\n             *             more secure, and more resistant to snooping or tampering.\n             *             If set to `true`, the API calls are made over HTTPS, at all\n             *             times. Setting to `false` will switch to HTTP (even if the\n             *             page is on HTTPS). And if set to `null`, current protocol will\n             *             be used. Note that some APIs might not work with HTTP such as\n             *             Google Maps TimeZone API.\n             *      @param {Object} [options.google]\n             *             Google specific options.\n             *          @param {String} [options.google.version=\"3\"]\n             *                 Google Maps API version to be used (with\n             *                 `geolocator.createMap()`) method. The default version\n             *                 value is tested and works with Geolocator. You can set a\n             *                 greater value or the latest version number and it should\n             *                 work; but it's not guaranteed. Find out the\n             *                 {@link https://developers.google.com/maps/documentation/javascript/versions|latest version here}.\n             *          @param {String} [options.google.key=\"\"]\n             *                 API key to be used with Google API calls. Although some\n             *                 calls might work without a key, it is generally required\n             *                 by most Goolge APIs. To get a free (or premium) key,\n             *                 {@link https://developers.google.com/maps/documentation/javascript/|click here}.\n             *          @param {Array} [options.google.styles]\n             *                 An array of objects to customize the presentation of the\n             *                 Google base maps, changing the visual display of such\n             *                 elements as roads, parks, and built-up areas.\n             *                 See {@link https://developers.google.com/maps/documentation/javascript/styling|Styling Maps}.\n             *\n             *  @returns {Object} - Returns the current or updated configuration object.\n             *\n             *  @example\n             *  geolocator.config({\n             *      language: \"en\",\n             *      google: {\n             *          version: \"3\",\n             *          key: \"YOUR-GOOGLE-API-KEY\"\n             *      }\n             *  });\n             */\n            value: function config(options) {\n              if (options) {\n                geolocator._.config = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend(defaultConfig, options);\n              }\n\n              return geolocator._.config;\n            }\n            /**\n             *  Gets a static map image URL which can be embeded via an `<img />` tag\n             *  on the page.\n             *\n             *  Note that, if `options.center` is set to an address (instead of\n             *  coordinates) and `options.marker` is also set; we will need to geocode\n             *  that address to get center coordinates for the marker.\n             *  In this case, you must use the `callback` parameter to get the async\n             *  result. Otherwise, this method will directly return a `String`.\n             *\n             *  Make sure you have enabled Static Maps API (and Geocoding API if\n             *  `marker` is enabled) in your Google Developers console.\n             *\n             *  For interactive map, see {@link #geolocator.createMap|`geolocator.createMap()` method}.\n             *\n             *  @see {@link https://developers.google.com/maps/documentation/static-maps/intro|Static Maps}\n             *  @see {@link https://developers.google.com/maps/documentation/static-maps/usage-limits|Usage Limits}\n             *\n             *  @param {Object} options\n             *         Static map options.\n             *         @param {String|Object} options.center\n             *                Defines the center of the map and the location.\n             *                Either an address `String` or an coordinates `Object` with\n             *                `latitude:Number` and `longitude:Number` properties.\n             *         @param {String} [options.mapTypeId=\"roadmap\"]\n             *                Type of the map to be created.\n             *                See {@link #geolocator.MapTypeId|`geolocator.MapTypeId` enumeration}\n             *                for possible values.\n             *         @param {String|Object} [options.size=\"600x300\"]\n             *                Defines the size (in pixels) of the returned image.\n             *                Either a string in `widthxheight` format or an Object\n             *                with `width:Number` and `height:Number` properties.\n             *         @param {Number} [options.scale=1]\n             *                Affects the number of pixels that are returned. scale=2\n             *                returns twice as many pixels as scale=1 while retaining\n             *                the same coverage area and level of detail (i.e. the\n             *                contents of the map don't change). Accepted values are 1,\n             *                2 and 4 (4 is only available to Google Maps APIs Premium\n             *                Plan customers.)\n             *         @param {Number} [options.zoom=9]\n             *                Zoom level to be set for the map.\n             *         @param {String} [options.format=png]\n             *                Defines the format of the resulting image.\n             *                See {@link #geolocator.ImageFormat|`geolocator.ImageFormat` enumeration}\n             *                for possible values.\n             *         @param {Boolean|String} [options.marker=true]\n             *                Specifies whether to add a marker to the center of the map.\n             *                You can define the color of the marker by passing a color\n             *                `String` instead of a `Boolean`. Color can be a predefined\n             *                color from the set `red` (default), `black`, `brown`,\n             *                `green`, `purple`, `yellow`, `blue`, `gray`, `orange` and\n             *                `white`; or a HEX 24-bit color (e.g. `\"0xFF0000\"`).\n             *                Note that marker will not be visible if `center` is set to\n             *                a `String` address and you don't use the callback.\n             *         @param {String} [options.region]\n             *                Defines the appropriate borders to display, based on\n             *                geo-political sensitivities. Accepts a region code\n             *                specified as a two-character ccTLD (top-level domain)\n             *                value. e.g. `\"us\"`.\n             *         @param {Array} [options.styles]\n             *                An array of objects to customize the presentation of the\n             *                Google base maps, changing the visual display of such\n             *                elements as roads, parks, and built-up areas.\n             *                This will default to the global styles set via\n             *                {@link #geolocator.config|`geolocator.config()` method}, if any.\n             *                See {@link https://developers.google.com/maps/documentation/javascript/styling|Styling Maps}.\n             *\n             *  @param {Function} [callback]\n             *         Callback function to be executed when the static map URL is built.\n             *         This takes 2 arguments: `function (err, url) { ... }`.\n             *         If omitted, this method will directly return the static map\n             *         image URL; but (if enabled) the marker will not be visible if\n             *         `options.center` is set to an address `String` instead of a\n             *         coordinates `Object`.\n             *\n             *  @returns {String|void}\n             *           If a callback is passed, this will return `void`.\n             *           Otherwise, a `String` that represents the URL of the static map.\n             *\n             *  @example\n             *  // Async example (with address and marker)\n             *  var options = {\n             *      center: \"Los Angles, CA, US\",\n             *      mapTypeId: geolocator.MapTypeId.ROADMAP,\n             *      size: \"600x300\",\n             *      scale: 1,\n             *      zoom: 5,\n             *      marker: \"0xFFCC00\",\n             *      format: geolocator.ImageFormat.PNG\n             *  };\n             *  geolocator.getStaticMap(options, function (err, url) {\n             *      if (!err) {\n             *          document.getElementById('my-img').src = url;\n             *      }\n             *  });\n             *\n             *  @example\n             *  // Sync example (with coordinates)\n             *  var options = {\n             *      center: {\n             *          longitude: 34.0522342,\n             *          latitude: -118.2436849\n             *      },\n             *      mapTypeId: geolocator.MapTypeId.ROADMAP,\n             *      size: \"600x300\",\n             *      scale: 1,\n             *      zoom: 5,\n             *      marker: \"0xFFCC00\",\n             *      format: geolocator.ImageFormat.PNG\n             *  };\n             *  document.getElementById('my-img').src = geolocator.getStaticMap(options);\n             */\n\n          }, {\n            key: 'getStaticMap',\n            value: function getStaticMap(options, callback) {\n              if (!_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(options) || !options.center) {\n                throw new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.INVALID_PARAMETERS, 'A center address or coordinates are required.');\n              }\n\n              if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(options.center)) {\n                return geolocator.geocode(options.center, function (err, location) {\n                  if (err) callback(err);\n                  options.center = location.coords;\n                  callback(null, geolocator.getStaticMap(options));\n                });\n              }\n\n              var conf = geolocator._.config;\n\n              var opts = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({\n                mapTypeId: _enums__WEBPACK_IMPORTED_MODULE_5__[\"default\"].MapTypeId.ROADMAP,\n                size: {\n                  width: 600,\n                  height: 300\n                },\n                scale: 1,\n                // 1 | 2 | (4 for business customers of google maps)\n                zoom: 9,\n                marker: 'red',\n                format: _enums__WEBPACK_IMPORTED_MODULE_5__[\"default\"].ImageFormat.PNG,\n                language: conf.language || 'en',\n                region: null\n              }, options);\n\n              var center = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(opts.center) ? opts.center.latitude + ',' + opts.center.longitude : String(opts.center);\n              var size = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(opts.size) ? opts.size.width + 'x' + opts.size.height : String(opts.size);\n              var url = _enums__WEBPACK_IMPORTED_MODULE_5__[\"default\"].URL.GOOGLE_SATATIC_MAP // not using utils.setProtocol() here\n              + ('?center=' + center + '&maptype=' + opts.mapTypeId) + ('&size=' + size + '&scale=' + opts.scale + '&zoom=' + opts.zoom) + ('&format=' + opts.format + '&language=' + opts.language);\n\n              if (opts.marker) {\n                var color = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(opts.marker) ? opts.marker : 'red';\n                url += '&markers=' + encodeURIComponent('color:' + color + '|' + center);\n              }\n\n              if (opts.region) url += '&region=' + opts.region;\n              if (conf.google.key) url += '&key=' + conf.google.key;\n              var styles = getStyles(opts);\n              if (styles) url += '&' + _geo_helper__WEBPACK_IMPORTED_MODULE_2__[\"default\"].mapStylesToParams(styles);\n              if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFunction(callback)) return callback(null, url);\n              return url;\n            }\n            /**\n             *  Creates an interactive Google Map within the given element.\n             *  Make sure you have enabled Google Static Maps API in your Google Developers console.\n             *  For static map, see {@link #geolocator.getStaticMap|`geolocator.getStaticMap()` method}.\n             *  @see {@link https://developers.google.com/maps/documentation/javascript/reference|Google Maps JavaScript API}\n             *  @see {@link https://developers.google.com/maps/documentation/javascript/usage|Usage Limits}\n             *\n             *  @param {Object|String|HTMLElement|Map} options\n             *         Either map options object with the following properties or; the ID\n             *         of a DOM element, or element itself which the map will be\n             *         created within; or a previously created `google.maps.Map` instance.\n             *         If a map instance is set, this only will apply the options without\n             *         re-creating it.\n             *      @param {String|HTMLElement|Map} options.element\n             *             Either the ID of a DOM element or the element itself;\n             *             which the map will be created within; or a previously created\n             *             `google.maps.Map` instance. If a map instance is set, this\n             *             only will apply the options without re-creating it.\n             *      @param {Object} options.center\n             *             Center coordinates for the map to be created.\n             *          @param {Number} options.center.latitude\n             *                 Latitude of the center point coordinates.\n             *          @param {Number} options.center.longitude\n             *                 Longitude of the center point coordinates.\n             *      @param {String} [options.mapTypeId=\"roadmap\"]\n             *             Type of the map to be created.\n             *             See {@link #geolocator.MapTypeId|`geolocator.MapTypeId` enumeration}\n             *             for possible values.\n             *      @param {String} [options.title]\n             *             Title text to be displayed within an `InfoWindow`, when the\n             *             marker is clicked. This only take effect if `marker` is\n             *             enabled.\n             *      @param {Boolean} [options.marker=true]\n             *             Whether to place a marker at the given coordinates.\n             *             If `title` is set, an `InfoWindow` will be opened when the\n             *             marker is clicked.\n             *      @param {Number} [options.zoom=9]\n             *             Zoom level to be set for the map.\n             *      @param {Array} [options.styles]\n             *             An array of objects to customize the presentation of the\n             *             Google base maps, changing the visual display of such\n             *             elements as roads, parks, and built-up areas.\n             *             This will default to the global styles set via\n             *             {@link #geolocator.config|`geolocator.config` method}`, if any.\n             *             See {@link https://developers.google.com/maps/documentation/javascript/styling|Styling Maps}.\n             *\n             *  @param {Function} callback\n             *         Callback function to be executed when the map is created.\n             *         This takes 2 arguments: `function (err, map) { ... }`.\n             *         See {@link #geolocator~MapData|`geolocator~MapData` type} for details.\n             *\n             *  @returns {void}\n             *\n             *  @example\n             *  var options = {\n             *      element: \"my-map\",\n             *      center: {\n             *          latitude: 48.8534100,\n             *          longitude: 2.3488000\n             *  \t},\n             *  \tmarker: true,\n             *  \ttitle: \"Paris, France\",\n             *  \tzoom: 12\n             *  };\n             *  geolocator.createMap(options, function (err, map) {\n             *      if (map && map.infoWindow) {\n             *          map.infoWindow.open(map.instance, map.marker);\n             *      }\n             *  });\n             */\n\n          }, {\n            key: 'createMap',\n            value: function createMap(options, callback) {\n              // if options is not a plain object, consider element ID, `HTMLElement`,\n              // `jQuery` instance or `google.maps.Map` instance.\n              if (!_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(options)) {\n                options = {\n                  element: options\n                };\n              }\n\n              options = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({\n                element: null,\n                mapTypeId: _enums__WEBPACK_IMPORTED_MODULE_5__[\"default\"].MapTypeId.ROADMAP,\n                title: undefined,\n                marker: true,\n                zoom: 9\n              }, options);\n              var e = options.element,\n                  elem = void 0;\n\n              if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(e)) {\n                elem = document.getElementById(e);\n              } else if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isJQueryObject(e)) {\n                elem = e[0];\n              } else if (geolocator.isGoogleLoaded() && e instanceof google.maps.Map) {\n                elem = e.getDiv();\n              }\n\n              if (!_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isElement(elem) && !_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNode(elem)) {\n                throw new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.INVALID_PARAMETERS, 'A valid DOM element or element ID is required to create a map.');\n              }\n\n              if (!_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(options.center) || !_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber(options.center.latitude) || !_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber(options.center.longitude)) {\n                throw new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.INVALID_PARAMETERS, 'Center coordinates are required to create a map.');\n              }\n\n              options.element = elem;\n              var conf = geolocator._.config,\n                  key = conf.google.key;\n              options.styles = getStyles(options);\n              geolocator.ensureGoogleLoaded(key, function (err) {\n                if (err) {\n                  throw new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.GOOGLE_API_FAILED, String(err.message || err));\n                }\n\n                var mapData = configCreateMap(options);\n                callback(null, mapData);\n              });\n            }\n            /**\n             *  Locates the user's location via HTML5 geolocation. This may\n             *  require/prompt for user's permission. If the permission is granted we'll\n             *  get the most accurate location information. Otherwise, we'll fallback to\n             *  locating via user's IP (if enabled).\n             *\n             *  For better accuracy, Geolocator implements a different approach than the\n             *  `getCurrentPosition` API; which generally triggers before the device's\n             *  GPS hardware can provide anything accurate. Thanks to\n             *  {@link https://github.com/gwilson/getAccurateCurrentPosition#background|Greg Wilson}\n             *  for the idea.\n             *\n             *  Also note that HTML5 Geolocation feature no more allows insecure origins.\n             *  See {@link https://goo.gl/rStTGz|this} for more details.\n             *  This means if you don't call this method from an HTTPS page, it will\n             *  fail. And if `options.fallbackToIP` is enabled, this will locate by IP.\n             *\n             *  @param {Object} [options]\n             *         HTML5 geo-location settings with some additional options.\n             *      @param {Boolean} [options.enableHighAccuracy=true]\n             *             Specifies whether the device should provide the most accurate\n             *             position it can. Note that setting this to `true` might\n             *             consume more CPU and/or battery power; and result in slower\n             *             response times.\n             *      @param {Number} [options.desiredAccuracy=30]\n             *             Minimum accuracy desired, in meters. Position will not be\n             *             returned until this is met, before the timeout. This only\n             *             takes effect if `enableHighAccuracy` is set to `true`.\n             *      @param {Number} [options.timeout=5000]\n             *             HTML5 position timeout setting in milliseconds. Setting this\n             *             to `Infinity` means that Geolocator won't return until the\n             *             position is available.\n             *      @param {Number} [options.maximumWait=10000]\n             *             Maximum time to wait (in milliseconds) for the desired\n             *             accuracy (which should be greater than `timeout`).\n             *             This only takes effect if `enableHighAccuracy` is set to\n             *             `true`.\n             *      @param {Number} [options.maximumAge=0]\n             *             HTML5 position maximum age. Indicates the maximum age in\n             *             milliseconds of a possible cached position that is acceptable\n             *             to return. `0` means, the device cannot use a cached position\n             *             and must attempt to retrieve the real current position. If set\n             *             to `Infinity` the device must return a cached position\n             *             regardless of its age. Note that if `enableHighAccuracy` is\n             *             set to `true`, `maximumAge` will be forced to `0`.\n             *      @param {Function} [options.onProgress]\n             *             If `enableHighAccuracy` is set to `true`, you can use this\n             *             callback to check the progress of the location accuracy;\n             *             while waiting for the final, best accurate location.\n             *      @param {Boolean} [options.fallbackToIP=false]\n             *             Specifies whether to fallback to IP geolocation if the HTML5\n             *             geolocation fails (e.g. user rejection).\n             *      @param {Boolean} [options.addressLookup=false]\n             *             Specifies whether to run a reverse-geocode operation for the\n             *             fetched coordinates to retrieve detailed address information.\n             *             Note that this means an additional request which requires a\n             *             Google API key to be set in the Geolocator configuration.\n             *             See {@link #geolocator.config|`geolocator.config()`}.\n             *      @param {Boolean} [options.timezone=false]\n             *             Specifies whether to also fetch the time zone information for\n             *             the receieved coordinates. Note that this means an additional\n             *             request which requires a Google API key to be set in the\n             *             Geolocator configuration.\n             *             See {@link #geolocator.config|`geolocator.config()`}.\n             *      @param {String|MapOptions} [options.map]\n             *             In order to create an interactive map from the fetched\n             *             location coordinates; either set this to a\n             *             {@link #geolocator~MapOptions|`MapOptions` object}\n             *             or; the ID of a DOM element or DOM element itself which the\n             *             map will be created within.\n             *      @param {Boolean|Object} [options.staticMap=false]\n             *             Set to `true` to get a static Google Map image URL (with\n             *             default options); or pass a static map options object.\n             *\n             *  @param {Function} callback\n             *         Callback function to be executed when the request completes.\n             *         This takes 2 arguments: `function (err, location) { ... }`.\n             *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n             *\n             *  @returns {void}\n             *\n             *  @example\n             *  var options = {\n             *      enableHighAccuracy: true,\n             *      desiredAccuracy: 30,\n             *      timeout: 5000,\n             *      maximumWait: 10000,\n             *      maximumAge: 0,\n             *      fallbackToIP: true,\n             *      addressLookup: true,\n             *      timezone: true,\n             *      map: \"my-map\",\n             *      staticMap: true\n             *  };\n             *  geolocator.locate(options, function (err, location) {\n             *      console.log(err || location);\n             *  });\n             *\n             * @example\n             *  // location result:\n             *  {\n             *      coords: {\n             *          latitude: 37.4224764,\n             *          longitude: -122.0842499,\n             *          accuracy: 30,\n             *          altitude: null,\n             *          altitudeAccuracy: null,\n             *          heading: null,\n             *          speed: null\n             *      },\n             *      address: {\n             *          commonName: \"\",\n             *          street: \"Amphitheatre Pkwy\",\n             *          route: \"Amphitheatre Pkwy\",\n             *          streetNumber: \"1600\",\n             *          neighborhood: \"\",\n             *          town: \"\",\n             *          city: \"Mountain View\",\n             *          region: \"Santa Clara County\",\n             *          state: \"California\",\n             *          stateCode: \"CA\",\n             *          postalCode: \"94043\",\n             *          country: \"United States\",\n             *          countryCode: \"US\"\n             *      },\n             *      formattedAddress: \"1600 Amphitheatre Parkway, Mountain View, CA 94043, USA\",\n             *      type: \"ROOFTOP\",\n             *      placeId: \"ChIJ2eUgeAK6j4ARbn5u_wAGqWA\",\n             *      timezone: {\n             *          id: \"America/Los_Angeles\",\n             *          name: \"Pacific Standard Time\",\n             *          abbr: \"PST\",\n             *          dstOffset: 0,\n             *          rawOffset: -28800\n             *      },\n             *      flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/us.svg\",\n             *      map: {\n             *          element: HTMLElement,\n             *          instance: Object, // google.maps.Map\n             *          marker: Object, // google.maps.Marker\n             *          infoWindow: Object, // google.maps.InfoWindow\n             *          options: Object // map options\n             *      },\n             *      staticMap: \"//maps.googleapis.com/maps/api/staticmap?center=37.4224764,-122.0842499&maptype=roadmap&size=600x300&scale=1&zoom=9&format=png&language=en&markers=color%3Ared%7C37.4224764%2C2-122.0842499&key=YOUR-GOOGLE-API-KEY\",\n             *      timestamp: 1456795956380\n             *  }\n             */\n\n          }, {\n            key: 'locate',\n            value: function locate(options, callback) {\n              options = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({\n                enableHighAccuracy: true,\n                timeout: 6000,\n                maximumWait: 10000,\n                maximumAge: 0,\n                desiredAccuracy: 30,\n                onProgress: _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n                fallbackToIP: false,\n                addressLookup: false,\n                timezone: false,\n                map: undefined,\n                staticMap: false\n              }, options); // force disable cache if high-accuracy is enabled\n\n              if (options.enableHighAccuracy) options.maximumAge = 0; // set a min value for timeout\n\n              if (options.timeout < 1000) options.timeout = 1000; // max wait should not be less than timeout\n\n              if (options.maximumWait < options.timeout) options.maximumWait = options.timeout; // check options and Google key\n\n              checkGoogleKey(options);\n              var cb = callbackMap(options, callback);\n\n              function fallbackToIP(error) {\n                if (options.fallbackToIP) {\n                  return geolocator.locateByIP(options, function (err, location) {\n                    if (err) return cb(err, null);\n                    return cb(null, location);\n                  });\n                }\n\n                cb(error, null);\n              }\n\n              function onPositionReceived(location) {\n                fetchAddressAndTimezone(location, options, cb);\n              }\n\n              function onPositionError(err) {\n                err = _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(err);\n                fallbackToIP(err);\n              }\n\n              if (geolocator.isGeolocationSupported()) {\n                if (options.enableHighAccuracy) {\n                  locateAccurate(options, onPositionReceived, onPositionError);\n                } else {\n                  navigator.geolocation.getCurrentPosition(onPositionReceived, onPositionError, options);\n                }\n              } else {\n                var err = new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.GEOLOCATION_NOT_SUPPORTED);\n                fallbackToIP(err);\n              }\n            }\n            /**\n             *  Returns a location and accuracy radius based on information about cell\n             *  towers and WiFi nodes that the mobile client can detect; via the Google\n             *  Maps Geolocation API.\n             *  @see {@link https://developers.google.com/maps/documentation/geolocation/intro|Google Maps Geolocation API}\n             *  @see {@link https://developers.google.com/maps/documentation/geolocation/usage-limits|Usage Limits}\n             *\n             *  @param {Object} [options]\n             *         Geolocation options.\n             *      @param {Number} [options.homeMobileCountryCode]\n             *             The mobile country code (MCC) for the device's home network.\n             *      @param {Number} [options.homeMobileNetworkCode]\n             *             The mobile network code (MNC) for the device's home network.\n             *      @param {String} [options.radioType]\n             *             The mobile radio type.\n             *             See {@link #geolocator.RadioType|`geolocator.RadioType` enumeration}\n             *             for possible values. While this field is optional, it should\n             *             be included if a value is available, for more accurate results.\n             *      @param {string} [options.carrier]\n             *             The carrier name. e.g. \"Vodafone\"\n             *      @param {Boolean} [options.fallbackToIP=false]\n             *             Specifies whether to fallback to IP geolocation if wifi and\n             *             cell tower signals are not available. Note that the IP address\n             *             in the request header may not be the IP of the device. Set\n             *             `fallbackToIP` to `false` to disable fall back.\n             *      @param {Array} [options.cellTowers]\n             *             An array of cell tower objects.\n             *             See {@link https://developers.google.com/maps/documentation/geolocation/intro#cell_tower_object|Cell tower objects} for details.\n             *      @param {Array} [options.wifiAccessPoints]\n             *             An array of WiFi access point objects.\n             *             See {@link https://developers.google.com/maps/documentation/geolocation/intro#wifi_access_point_object|WiFi access point objects} for details.\n             *      @param {Boolean} [options.addressLookup=false]\n             *             Specifies whether to run a reverse-geocode operation for the\n             *             fetched coordinates to retrieve detailed address information.\n             *             Note that this means an additional request which requires a\n             *             Google API key to be set in the Geolocator configuration.\n             *             See {@link #geolocator.config|`geolocator.config()`}.\n             *      @param {Boolean} [options.timezone=false]\n             *             Specifies whether to also fetch the time zone information for\n             *             the receieved coordinates. Note that this means an additional\n             *             request which requires a Google API key to be set in the\n             *             Geolocator configuration.\n             *             See {@link #geolocator.config|`geolocator.config()`}.\n             *      @param {String|MapOptions} [options.map]\n             *             In order to create an interactive map from the fetched\n             *             location coordinates; either set this to a\n             *             {@link #geolocator~MapOptions|`MapOptions` object}\n             *             or; the ID of a DOM element or DOM element itself which the\n             *             map will be created within.\n             *      @param {Boolean|Object} [options.staticMap=false]\n             *             Set to `true` to get a static Google Map image URL (with\n             *             default options); or pass a static map options object.\n             *      @param {Boolean} [options.raw=false]\n             *      \t      Whether to return the raw Google API result.\n             *  @param {Function} callback\n             *         Callback function to be executed when the request completes.\n             *         This takes 2 arguments: `function (err, location) { ... }`.\n             *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n             *\n             *  @returns {void}\n             *\n             *  @example\n             *  var options = {\n             *      homeMobileCountryCode: 310,\n             *      homeMobileNetworkCode: 410,\n             *      carrier: 'Vodafone',\n             *      radioType: geolocator.RadioType.GSM,\n             *      fallbackToIP: true,\n             *      addressLookup: false,\n             *      timezone: false,\n             *      map: \"my-map\",\n             *      staticMap: false\n             *  };\n             *  geolocator.locateByMobile(options, function (err, location) {\n             *      console.log(err || location);\n             *  });\n             */\n\n          }, {\n            key: 'locateByMobile',\n            value: function locateByMobile(options, callback) {\n              if (!_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(options)) {\n                throw new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.INVALID_PARAMETERS);\n              }\n\n              var cb = callbackMap(options, callback);\n              options = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({\n                homeMobileCountryCode: undefined,\n                homeMobileNetworkCode: undefined,\n                radioType: undefined,\n                carrier: undefined,\n                fallbackToIP: false,\n                cellTowers: undefined,\n                wifiAccessPoints: undefined,\n                addressLookup: false,\n                timezone: false,\n                map: undefined,\n                raw: false\n              }, options);\n              options.considerIp = options.fallbackToIP; // check Google key\n\n              checkGoogleKey();\n\n              var conf = geolocator._.config,\n                  key = conf.google.key || '',\n                  url = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setProtocol(_enums__WEBPACK_IMPORTED_MODULE_5__[\"default\"].URL.GOOGLE_GEOLOCATION, conf.https),\n                  xhrOpts = {\n                url: url + '?key=' + key,\n                headers: {\n                  'Content-Type': 'application/json'\n                },\n                data: JSON.stringify(options)\n              }; // console.log(xhrOpts.data);\n\n\n              _lib_fetch__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(xhrOpts, function (err, xhr) {\n                var response = getXHRResponse(err, xhr);\n                if (_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isGeoError(response)) return cb(response, null);\n                response = options.raw ? response : {\n                  coords: {\n                    latitude: response.location.lat,\n                    longitude: response.location.lng,\n                    accuracy: response.accuracy\n                  },\n                  timestamp: _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].time()\n                };\n                fetchAddressAndTimezone(response, options, cb); // e.g. raw response\n                // {\n                //     \"location\": {\n                //         \"lat\": 51.0,\n                //         \"lng\": -0.1\n                //     },\n                //     \"accuracy\": 1200.4\n                // }\n              });\n            }\n            /**\n             *  Locates the user's location by the client's IP.\n             *\n             *  This method uses a free lookup service, by default.\n             *  In order to change the source provider, you can use\n             *  {@link #geolocator.setGeoIPSource|`geolocator.setGeoIPSource()` method}.\n             *\n             *  @param {Object} [options]\n             *         Locate options.\n             *      @param {Boolean} [options.addressLookup=false]\n             *             Specifies whether to run a reverse-geocode operation for the\n             *             fetched coordinates to retrieve detailed address information.\n             *             Since no precise address can be fetched from an IP addres; you\n             *             should only enable this if the Geo-IP Source returns no useful\n             *             address information other than coordinates. Also, note that\n             *             this means an additional request which requires a Google API\n             *             key to be set in the Geolocator configuration.\n             *             See {@link #geolocator.config|`geolocator.config()`}.\n             *      @param {Boolean} [options.timezone=false]\n             *             Specifies whether to also fetch the time zone information for\n             *             the receieved coordinates. Note that this means an additional\n             *             request which requires a Google API key to be set in the\n             *             Geolocator configuration.\n             *             See {@link #geolocator.config|`geolocator.config()`}.\n             *      @param {String|MapOptions} [options.map]\n             *             In order to create an interactive map from the fetched\n             *             location coordinates; either set this to a\n             *             {@link #geolocator~MapOptions|`MapOptions` object}\n             *             or; the ID of a DOM element or DOM element itself which the\n             *             map will be created within.\n             *      @param {Boolean|Object} [options.staticMap=false]\n             *             Set to `true` to get a static Google Map image URL (with\n             *             default options); or pass a static map options object.\n             *  @param {Function} callback\n             *         Callback function to be executed when the request completes.\n             *         This takes 2 arguments: `function (err, location) { ... }`.\n             *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n             *\n             *  @returns {void}\n             *\n             *  @example\n             *  var options = {\n             *  \taddressLookup: true,\n             *  \ttimezone: true,\n             *  \tmap: \"my-map\",\n             *  \tstaticMap: true\n             *  };\n             *  geolocator.locateByIP(options, function (err, location) {\n             *  \tconsole.log(err || location);\n             *  });\n             *\n             *  @example\n             *  // location result:\n             *  {\n             *      coords: {\n             *          latitude: 41.0214,\n             *          longitude: 28.9948,\n             *      },\n             *      address: {\n             *          city: \"Istanbul\",\n             *          region: \"34\",\n             *          state: \"34\",\n             *          country: \"Turkey\",\n             *          countryCode: \"TR\"\n             *      },\n             *      formattedAddress: \"Demirtaş, Tesviyeci Sk. No:7, 34134 Fatih/İstanbul, Turkey\",\n             *      type: \"ROOFTOP\",\n             *      placeId: \"ChIJ-ZRLfO25yhQRBi5YJxX80Q0\",\n             *      timezone: {\n             *          id: \"Europe/Istanbul\",\n             *          name: \"Eastern European Summer Time\",\n             *          abbr: \"EEST\",\n             *          dstOffset: 3600,\n             *          rawOffset: 7200\n             *      },\n             *      flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/tr.svg\",\n             *      map: {\n             *          element: HTMLElement,\n             *          instance: Object, // google.maps.Map\n             *          marker: Object, // google.maps.Marker\n             *          infoWindow: Object, // google.maps.InfoWindow\n             *          options: Object // map options\n             *      },\n             *      staticMap: \"//maps.googleapis.com/maps/api/staticmap?center=41.0214,28.9948&maptype=roadmap&size=600x300&scale=1&zoom=9&format=png&language=en&markers=color%3Ared%7C41.0214%2C228.9948&key=YOUR-GOOGLE-API-KEY\",\n             *      provider: \"geobytes\",\n             *      timestamp: 1466216325223\n             *  }\n             */\n\n          }, {\n            key: 'locateByIP',\n            value: function locateByIP(options, callback) {\n              // passed source can be a string or object\n              var source = geolocator._.geoIpSource;\n\n              if (!_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(source)) {\n                throw new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.INVALID_GEO_IP_SOURCE, 'Please set a valid Geo-IP Source via geolocator.setGeoIPSource(options).');\n              } // check options and Google key\n\n\n              checkGoogleKey(options || {});\n\n              function updateResponse(response) {\n                if (!response) {\n                  var err = new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.INVALID_RESPONSE);\n                  return callback(err, null);\n                }\n\n                if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(source.schema)) {\n                  response = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mapToSchema(response, source.schema);\n                } else if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFunction(source.schema)) {\n                  response = source.schema(response);\n                }\n\n                response.provider = source.provider || 'unknown';\n                setLocationURLs(response, options);\n\n                if (response.coords) {\n                  response.coords.latitude = Number(response.coords.latitude);\n                  response.coords.longitude = Number(response.coords.longitude);\n                }\n\n                var cb = callbackMap(options, callback);\n                fetchAddressAndTimezone(response, options, cb);\n              }\n\n              if (source.xhr) {\n                var opts = {\n                  url: source.url,\n                  async: true\n                };\n                return _lib_fetch__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(opts, function (err, xhr) {\n                  var response = xhr.responseText ? JSON.parse(xhr.responseText) : null;\n                  if (err) return callback(_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(err), null);\n                  updateResponse(response);\n                });\n              }\n\n              if (source.callbackParam || source.globalVar) {\n                var jsonpOpts = {\n                  url: source.url,\n                  async: true,\n                  clean: true // params: {}\n\n                };\n\n                if (source.callbackParam) {\n                  jsonpOpts.callbackParam = source.callbackParam;\n                  jsonpOpts.rootName = 'geolocator._.cb';\n                }\n\n                return _lib_fetch__WEBPACK_IMPORTED_MODULE_1__[\"default\"].jsonp(jsonpOpts, function (err, response) {\n                  if (err) return callback(_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(err), null);\n\n                  if (source.globalVar) {\n                    if (window[source.globalVar]) {\n                      response = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clone(window[source.globalVar]);\n                      delete window[source.globalVar];\n                    } else {\n                      response = null;\n                    }\n                  }\n\n                  updateResponse(response);\n                });\n              }\n\n              throw new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.INVALID_GEO_IP_SOURCE, 'Either xhr, callbackParam or globalVar should be set for Geo-IP source.');\n            }\n            /**\n             *  Sets the Geo-IP source to be used for fetching location information\n             *  by user's IP; which is internally used by\n             *  {@link #geolocator.locateByIP|`geolocator.locateByIP()` method}.\n             *\n             *  By default, Geolocator uses a free Geo-IP source provider.\n             *  You can use this method to change this; or you can choose from\n             *  ready-to-use\n             *  {@link https://github.com/onury/geolocator/tree/master/src/geo-ip-sources|Geo-IP sources}.\n             *\n             *  @param {Object} options\n             *         Geo-IP Source options.\n             *      @param {String} [options.provider]\n             *             Source or service provider's name.\n             *      @param {String} options.url\n             *             Source URL without the callback query parameter. The callback\n             *             name (if supported) should be set via `options.callbackParam`.\n             *             Also, make sure the service supports the protocol you use in\n             *             the enums.URL. If it supports both HTTP and HTTPS, you can omit the\n             *             protocol. In this case, it will be determined via Geolocator\n             *             configuration.\n             *             See {@link #geolocator.config|`geolocator.config()`}.\n             *             NOTE: Do not forget to include your API key in the query\n             *             parameters of the URL, if you have one.\n             *      @param {String} [options.callbackParam]\n             *             If JSON callback is supported, pass the name of the callback\n             *             parameter, defined by the provider.\n             *      @param {Object} [options.globalVar]\n             *             Set this instead of `options.callbackParam` if the service\n             *             does not support JSON callbacks, but weirdly set a global\n             *             variable in the document. For example, if the response is\n             *             `Geo = { lat, lng }`, you should set this to `\"Geo\"`.\n             *      @param {Object} [options.schema]\n             *             Schema object to be used to re-structure the response returned\n             *             from the service. Set the response object's keys as values of\n             *             a custom object to map the format to the `location` object.\n             *             For example; if the service returns a response like\n             *             `{ lat: 40.112233, lng: 10.112233, otherProp: 'hello' }`.\n             *             Then you should set the following schema:\n             *             `{ coords: { latitude: 'lat', longitude: 'lng' } }`.\n             *\n             *  @return {geolocator}\n             */\n\n          }, {\n            key: 'setGeoIPSource',\n            value: function setGeoIPSource(options) {\n              if (!_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(options)) {\n                throw new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.INVALID_PARAMETERS, 'Geo-IP source options is invalid.');\n              }\n\n              if (!_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isStringSet(options.url)) {\n                throw new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.INVALID_PARAMETERS, 'Geo-IP source should have a valid URI.');\n              } // if (!utils.isStringSet(options.callbackParam) && !utils.isStringSet(options.globalVar)) {\n              //     throw new GeoError(GeoError.Code.INVALID_PARAMETERS, 'No \\'callbackParam\\' or \\'globalVar\\' is provided for the Geo-IP Source options.');\n              // }\n\n\n              geolocator._.geoIpSource = Object.freeze(options);\n            }\n            /**\n             *  Registers a handler for watching the user's location via HTML5\n             *  geolocation; that is triggered each time the position of the device\n             *  changes. This may require/prompt for user's permission.\n             *\n             *  @param {Object} [options]\n             *         HTML5 geo-location settings.\n             *      @param {Boolean} [options.enableHighAccuracy=true]\n             *             Specifies whether the device should provide the most accurate\n             *             position it can. Note that setting this to `true` might consume\n             *             more CPU and/or battery power; and result in slower response\n             *             times.\n             *      @param {Number} [options.timeout=6000]\n             *             HTML5 position timeout setting in milliseconds. Setting this\n             *             to `Infinity` means that Geolocator won't return until the\n             *             position is available.\n             *      @param {Number} [options.maximumAge=0]\n             *             HTML5 position maximum age. Indicates the maximum age in\n             *             milliseconds of a possible cached position that is acceptable\n             *             to return. `0` means, the device cannot use a cached position\n             *             and must attempt to retrieve the real current position. If set\n             *             to `Infinity` the device must return a cached position\n             *             regardless of its age.\n             *      @param {Boolean} [options.clearOnError=false]\n             *             Specifies whether to clear the watcher on first error so that\n             *             it does not execute any more callbacks.\n             *      @param {Object} [options.target]\n             *             Object that defines the target location and settings; that\n             *             when the location is reached, the watcher will auto-clear\n             *             itself and invoke the callback.\n             *      @param {Number} options.target.latitude\n             *             The `latitude` of the target location.\n             *      @param {Number} options.target.longitude\n             *             The `longitude` of the target location.\n             *      @param {Number} [options.target.radius=0.5]\n             *             The radius, in other words; the minimum distance (in\n             *             kilometers or miles) to the target point that should be\n             *             reached.\n             *      @param {Number} [options.target.unitSystem=0]\n             *             Unit system to be used for target radius.\n             *             See {@link #geolocator.UnitSystem|`geolocator.UnitSystem` enumeration}\n             *             for possible values.\n             *  @param {Function} callback\n             *         Callback function to be executed when the request completes.\n             *         This takes 2 arguments: `function (err, location) { ... }`.\n             *         If `options.target` is set, `location` will also\n             *         include a `targetReached:Boolean` property.\n             *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n             *\n             *  @returns {GeoWatcher} - A watcher object that provides a\n             *  `.clear(delay:Number, callback:Function)` method to clear the watcher\n             *  when needed. Optional `delay` argument can be set (in milliseconds) to\n             *  clear in a later time. Omitting this argument will clear the watcher\n             *  immediately. You should always call this method, except if you've set up\n             *  a target; which will auto-clear the watcher when reached.\n             *\n             *  @example\n             *  // Watch my position for 5 minutes.\n             *  var options = { enableHighAccuracy: true, timeout: 6000, maximumAge: 0 };\n             *  var watcher = geolocator.watch(options, function (err, location) {\n             *      console.log(err || location);\n             *  });\n             *  console.log(watcher.id); // ID of the watcher\n             *  watcher.clear(300000); // clear after 5 minutes.\n             *\n             *  @example\n             *  // Watch my position until I'm 350 meters near Disneyland Park.\n             *  options.target = {\n             *      latitude: 33.8120918,\n             *      longitude: -117.9233569,\n             *      radius: 0.35,\n             *      unitSystem: geolocator.UnitSystem.METRIC\n             *  };\n             *  watcher = geolocator.watch(options, function (err, location) {\n             *      if (err) {\n             *          console.log(err);\n             *          return;\n             *      }\n             *      if (location.targetReached) {\n             *          console.log(watcher.isCleared); // true\n             *          console.log(watcher.cycle); // 15 — target reached after 15 cycles\n             *      } else {\n             *          console.log(watcher.isCleared); // false — watcher is active.\n             *      }\n             *  });\n             */\n\n          }, {\n            key: 'watch',\n            value: function watch(options, callback) {\n              if (!geolocator.isGeolocationSupported()) {\n                callback(new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.GEOLOCATION_NOT_SUPPORTED), null);\n                return {};\n              }\n\n              var watcher = void 0,\n                  target = void 0;\n              options = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({\n                enableHighAccuracy: true,\n                timeout: 6000,\n                maximumAge: 0,\n                clearOnError: false\n              }, options);\n\n              if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(options.target)) {\n                target = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({\n                  radius: 0.5,\n                  unitSystem: geolocator.UnitSystem.METRIC\n                }, options.target);\n              }\n\n              function onPositionChanged(location) {\n                var pos = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clone(location, {\n                  own: false\n                });\n\n                if (target) {\n                  var distance = geolocator.calcDistance({\n                    from: location.coords,\n                    to: target,\n                    formula: geolocator.DistanceFormula.HAVERSINE,\n                    unitSystem: target.unitSystem\n                  });\n                  pos.targetReached = distance <= target.radius;\n\n                  if (watcher && pos.targetReached) {\n                    watcher.clear(function () {\n                      return callback(null, pos);\n                    });\n                  }\n                }\n\n                return callback(null, pos);\n              }\n\n              function onPositionError(err) {\n                callback(_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(err), null);\n              }\n\n              return new _geo_watcher__WEBPACK_IMPORTED_MODULE_4__[\"default\"](onPositionChanged, onPositionError, options);\n            }\n            /**\n             *  Converts a given address (or address components) into geographic\n             *  coordinates (i.e. latitude, longitude); and gets detailed address\n             *  information.\n             *  @see {@link https://developers.google.com/maps/documentation/geocoding/intro|Google Maps Geocoding API}\n             *  @see {@link https://developers.google.com/maps/documentation/geocoding/usage-limits|Usage Limits}\n             *\n             *  @param {String|Object} options\n             *         Either the address to geocode or geocoding options with the\n             *         following properties.\n             *      @param {String} options.address\n             *             The street address to geocode, in the format used by the\n             *             national postal service of the country concerned. Additional\n             *             address elements such as business names and unit, suite or\n             *             floor numbers should be avoided. Note that any address\n             *             component (route, locality, administrativeArea, postalCode and\n             *             country) should be specified either in address or the\n             *             corresponding property - not both. Doing so may result in\n             *             `ZERO_RESULTS`.\n             *      @param {String} [options.route]\n             *      \t      Long or short name of a route.\n             *      @param {String} [options.locality]\n             *      \t      Locality and sublocality of the location.\n             *      @param {String} [options.administrativeArea]\n             *      \t      Administrative area of the location.\n             *      @param {String} [options.postalCode]\n             *      \t      Postal code of the location.\n             *      @param {String} [options.country]\n             *      \t      A country name or a two letter ISO 3166-1 country code.\n             *      @param {String} [options.region]\n             *      \t      The region code, specified as a ccTLD (\"top-level domain\")\n             *      \t      two-character value. e.g.: `\"fr\"` for France.\n             *      @param {Array|Object} [options.bounds]\n             *      \t      The bounding box of the viewport within which to bias geocode\n             *      \t      results more prominently. e.g.:\n             *      \t      `[ southwestLat:Number, southwestLng:Number, northeastLat:Number, northeastLng:Number ]`\n             *      @param {String|MapOptions} [options.map]\n             *             In order to create an interactive map from the fetched\n             *             location coordinates; either set this to a\n             *             {@link #geolocator~MapOptions|`MapOptions` object}\n             *             or; the ID of a DOM element or DOM element itself which the\n             *             map will be created within.\n             *      @param {Boolean|Object} [options.staticMap=false]\n             *             Set to `true` to get a static Google Map image URL (with\n             *             default options); or pass a static map options object.\n             *      @param {Boolean} [options.raw=false]\n             *      \t      Whether to return the raw Google API result.\n             *  @param {Function} callback\n             *         Callback function to be executed when the request completes.\n             *         This takes 2 arguments: `function (err, location) { ... }`.\n             *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n             *\n             *  @returns {void}\n             *\n             *  @example\n             *  var address = '1600 Amphitheatre Parkway, CA';\n             *  geolocator.geocode(address, function (err, location) {\n             *      console.log(err || location);\n             *  });\n             *\n             *  @example\n             *  // location result:\n             *  {\n             *      coords: {\n             *          latitude: 37.4224764,\n             *          longitude: -122.0842499\n             *      },\n             *      address: {\n             *          commonName: \"\",\n             *          street: \"Amphitheatre Pkwy\",\n             *          route: \"Amphitheatre Pkwy\",\n             *          streetNumber: \"1600\",\n             *          neighborhood: \"\",\n             *          town: \"\",\n             *          city: \"Mountain View\",\n             *          region: \"Santa Clara County\",\n             *          state: \"California\",\n             *          stateCode: \"CA\",\n             *          postalCode: \"94043\",\n             *          country: \"United States\",\n             *          countryCode: \"US\"\n             *      },\n             *      formattedAddress: \"1600 Amphitheatre Parkway, Mountain View, CA 94043, USA\",\n             *      type: \"ROOFTOP\",\n             *      placeId: \"ChIJ2eUgeAK6j4ARbn5u_wAGqWA\",\n             *      flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/us.svg\",\n             *      map: {\n             *          element: HTMLElement,\n             *          instance: Object, // google.maps.Map\n             *          marker: Object, // google.maps.Marker\n             *          infoWindow: Object, // google.maps.InfoWindow\n             *          options: Object // map options\n             *      },\n             *      timestamp: 1456795956380\n             *  }\n             */\n\n          }, {\n            key: 'geocode',\n            value: function geocode(options, callback) {\n              _geocode(false, options, callback);\n            }\n            /**\n             *  Converts the given geographic coordinates into a human-readable address\n             *  information.\n             *  @see {@link https://developers.google.com/maps/documentation/geocoding/intro#ReverseGeocoding|Google Maps (Reverse) Geocoding API}\n             *  @see {@link https://developers.google.com/maps/documentation/geocoding/usage-limits|Usage Limits}\n             *  @alias geolocator.addressLookup\n             *\n             *  @param {Object|String} options\n             *         Either the `placeId` of the location or Reverse Geocoding options\n             *         with the following properties.\n             *      @param {Number} options.latitude\n             *      Latitude of the target location.\n             *      @param {Number} options.longitude\n             *      Longitude of the target location.\n             *      @param {String} [options.placeId]\n             *             Required if `latitude` and `longitude` are omitted. The place\n             *             ID of the place for which you wish to obtain the\n             *             human-readable address. The place ID is a unique identifier\n             *             that can be used with other Google APIs. Note that if\n             *             `placeId` is set, `latitude` and `longitude` are ignored.\n             *      @param {String|MapOptions} [options.map]\n             *             In order to create an interactive map from the fetched\n             *             location coordinates; either set this to a\n             *             {@link #geolocator~MapOptions|`MapOptions` object}\n             *             or; the ID of a DOM element or DOM element itself which the\n             *             map will be created within.\n             *      @param {Boolean|Object} [options.staticMap=false]\n             *             Set to `true` to get a static Google Map image URL (with\n             *             default options); or pass a static map options object.\n             *      @param {Boolean} [options.raw=false]\n             *             Whether to return the raw Google API result.\n             *  @param {Function} callback\n             *         Callback function to be executed when the request completes.\n             *         This takes 2 arguments: `function (err, location) { ... }`\n             *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n             *\n             *  @returns {void}\n             *\n             *  @example\n             *  var coords = {\n             *      latitude: 37.4224764,\n             *      longitude: -122.0842499\n             *  };\n             *\n             *  geolocator.reverseGeocode(coords, function (err, location) {\n             *      console.log(err || location);\n             *  });\n             *\n             *  @example\n             *  // location result:\n             *  {\n             *      coords: {\n             *          latitude: 37.4224764,\n             *          longitude: -122.0842499\n             *      },\n             *      address: {\n             *          commonName: \"\",\n             *          street: \"Amphitheatre Pkwy\",\n             *          route: \"Amphitheatre Pkwy\",\n             *          streetNumber: \"1600\",\n             *          neighborhood: \"\",\n             *          town: \"\",\n             *          city: \"Mountain View\",\n             *          region: \"Santa Clara County\",\n             *          state: \"California\",\n             *          stateCode: \"CA\",\n             *          postalCode: \"94043\",\n             *          country: \"United States\",\n             *          countryCode: \"US\"\n             *      },\n             *      formattedAddress: \"1600 Amphitheatre Parkway, Mountain View, CA 94043, USA\",\n             *      type: \"ROOFTOP\",\n             *      placeId: \"ChIJ2eUgeAK6j4ARbn5u_wAGqWA\",\n             *      flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/us.svg\",\n             *      map: {\n             *          element: HTMLElement,\n             *          instance: Object, // google.maps.Map\n             *          marker: Object, // google.maps.Marker\n             *          infoWindow: Object, // google.maps.InfoWindow\n             *          options: Object // map options\n             *      },\n             *      timestamp: 1456795956380\n             *  }\n             */\n\n          }, {\n            key: 'reverseGeocode',\n            value: function reverseGeocode(options, callback) {\n              _geocode(true, options, callback);\n            }\n            /**\n             *  Alias for `geolocator.reverseGeocode`\n             *  @private\n             */\n\n          }, {\n            key: 'addressLookup',\n            value: function addressLookup(options, callback) {\n              geolocator.reverseGeocode(options, callback);\n            }\n            /**\n             *  Gets timezone information for the given coordinates.\n             *  Note: Google Browser API keys cannot have referer restrictions when used with this API.\n             *  @see {@link https://developers.google.com/maps/documentation/timezone/intro|Google Maps TimeZone API}\n             *  @see {@link https://developers.google.com/maps/documentation/timezone/usage-limits|Usage Limits}\n             *\n             *  @param {Object} options\n             *         Time zone options.\n             *      @param {Number} options.latitude\n             *             Latitude of location.\n             *      @param {Number} options.longitude\n             *             Longitude of location.\n             *      @param {Number} [options.timestamp=Date.now()]\n             *             Specifies the desired time as seconds since midnight, January\n             *             1, 1970 UTC. This is used to determine whether or not Daylight\n             *             Savings should be applied.\n             *      @param {Boolean} [options.raw=false]\n             *             Whether to return the raw Google API result.\n             *  @param {Function} callback\n             *         Callback function to be executed when the request completes, in\n             *         the following signature: `function (err, timezone) { ... }`.\n             *         See {@link #geolocator~TimeZone|`geolocator~TimeZone` type} for\n             *         details.\n             *\n             *  @returns {void}\n             *\n             *  @example\n             *  var options = {\n             *      latitude: 48.8534100,\n             *      longitude: 2.3488000\n             *  };\n             *  geolocator.getTimeZone(options, function (err, timezone) {\n             *      console.log(err || timezone);\n             *  });\n             *\n             *  @example\n             *  // timezone result:\n             *  {\n             *      id: \"Europe/Paris\",\n             *      name: \"Central European Standard Time\",\n             *      abbr: \"CEST\",\n             *      dstOffset: 0,\n             *      rawOffset: 3600,\n             *      timestamp: 1455733120\n             *  }\n             */\n\n          }, {\n            key: 'getTimeZone',\n            value: function getTimeZone(options, callback) {\n              if (!_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(options) || !_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber(options.latitude) || !_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber(options.longitude)) {\n                throw new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.INVALID_PARAMETERS);\n              }\n\n              checkGoogleKey();\n              var conf = geolocator._.config;\n              options = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({\n                key: conf.google.key || '',\n                language: conf.language || 'en',\n                timestamp: _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].time(true),\n                raw: false\n              }, options);\n\n              var url = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setProtocol(_enums__WEBPACK_IMPORTED_MODULE_5__[\"default\"].URL.GOOGLE_TIMEZONE, conf.https),\n                  xhrOpts = {\n                url: url + '?location=' + options.latitude + ',' + options.longitude + '&timestamp=' + options.timestamp + '&language=' + options.language + '&key=' + options.key\n              };\n\n              _lib_fetch__WEBPACK_IMPORTED_MODULE_1__[\"default\"].xhr(xhrOpts, function (err, xhr) {\n                var response = getXHRResponse(err, xhr);\n                if (_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isGeoError(response)) return callback(response, null);\n                response = options.raw ? response : {\n                  id: response.timeZoneId,\n                  name: response.timeZoneName,\n                  abbr: _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].abbr(response.timeZoneName, {\n                    dots: false\n                  }),\n                  dstOffset: response.dstOffset,\n                  rawOffset: response.rawOffset,\n                  timestamp: options.timestamp\n                };\n                callback(err, response);\n              });\n            }\n            /**\n             *  Gets the distance and duration values based on the recommended route\n             *  between start and end points.\n             *  @see {@link https://developers.google.com/maps/documentation/distance-matrix/intro|Google Maps Distance Matrix API}\n             *  @see {@link https://developers.google.com/maps/documentation/distance-matrix/usage-limits|Usage Limits}\n             *\n             *  @param {Object} options\n             *         Distance matrix options.\n             *      @param {String|Object|Array} options.origins\n             *             One or more addresses and/or an object of latitude/longitude\n             *             values, from which to calculate distance and time. If you pass\n             *             an address as a string, the service will geocode the string\n             *             and convert it to a latitude/longitude coordinate to calculate\n             *             distances. Following are valid examples:\n             *  <pre><code>options.origins = 'London';\n             *  options.origins = ['London', 'Paris'];\n             *  options.origins = { latitude: 51.5085300, longitude: -0.1257400 };\n             *  options.origins = [\n             *      { latitude: 51.5085300, longitude: -0.1257400 },\n             *      { latitude: 48.8534100, longitude: 2.3488000 }\n             *  ];\n             *  </code></pre>\n             *      @param {String|Object|Array} options.destinations\n             *             One or more addresses and/or an object of latitude/longitude\n             *             values, from which to calculate distance and time. If you pass\n             *             an address as a string, the service will geocode the string\n             *             and convert it to a latitude/longitude coordinate to calculate\n             *             distances.\n             *      @param {String} [options.travelMode=\"DRIVING\"]\n             *             Type of routing requested.\n             *             See {@link #geolocator.TravelMode|`geolocator.TravelMode` enumeration}\n             *             for possible values.\n             *      @param {Boolean} [options.avoidFerries]\n             *             If true, instructs the Distance Matrix service to avoid\n             *             ferries where possible.\n             *      @param {Boolean} [options.avoidHighways]\n             *             If true, instructs the Distance Matrix service to avoid\n             *             highways where possible.\n             *      @param {Boolean} [options.avoidTolls]\n             *             If true, instructs the Distance Matrix service to avoid toll\n             *             roads where possible.\n             *      @param {Number} [options.unitSystem=0]\n             *             Preferred unit system to use when displaying distance.\n             *             See {@link #geolocator.UnitSystem|`geolocator.UnitSystem` enumeration}\n             *             for possible values.\n             *      @param {String} [options.region]\n             *             Region code used as a bias for geocoding requests.\n             *  @param {Boolean} [options.raw=false]\n             *         Whether to return the raw Google API result.\n             *  @param {Function} callback\n             *         Callback function to be executed when the request completes,\n             *         in the following signature: `function (err, result) { ... }`\n             *\n             *  @returns {void}\n             *\n             *  @example\n             *  var options = {\n             *      origins: [{ latitude: 51.5085300, longitude: -0.1257400 }],\n             *      destinations: [{ latitude: 48.8534100, longitude: 2.3488000 }],\n             *      travelMode: geolocator.TravelMode.DRIVING,\n             *      unitSystem: geolocator.UnitSystem.METRIC\n             *  };\n             *  geolocator.getDistanceMatrix(options, function (err, result) {\n             *      console.log(err || result);\n             *  });\n             *\n             *  @example\n             *  // result:\n             *  [\n             *  \t{\n             *  \t\tfrom: \"449 Duncannon St, London WC2R 0DZ, UK\",\n             *  \t\tto: \"1 Parvis Notre-Dame - Pl. Jean-Paul II, 75004 Paris-4E-Arrondissement, France\",\n             *  \t\tdistance: {\n             *  \t\t\tvalue: 475104,\n             *  \t\t\ttext: \"475 km\"\n             *  \t\t},\n             *  \t\tduration: {\n             *  \t\t\tvalue: 20193,\n             *  \t\t\ttext: \"5 hours 37 mins\"\n             *  \t\t},\n             *  \t\tfare: undefined,\n             *  \t\ttimestamp: 1456795956380\n             *  \t}\n             *  ]\n             */\n\n          }, {\n            key: 'getDistanceMatrix',\n            value: function getDistanceMatrix(options, callback) {\n              checkGoogleKey();\n              var key = geolocator._.config.google.key;\n              geolocator.ensureGoogleLoaded(key, function (err) {\n                if (err) {\n                  throw new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.GOOGLE_API_FAILED, String(err.message || err));\n                }\n\n                var o = options.origins || options.origin || options.from,\n                    d = options.destinations || options.destination || options.to;\n\n                if (!_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(options) || invalidOriginOrDest(o) || invalidOriginOrDest(d)) {\n                  throw new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.INVALID_PARAMETERS);\n                }\n\n                options.origins = _geo_helper__WEBPACK_IMPORTED_MODULE_2__[\"default\"].toPointList(o);\n                options.destinations = _geo_helper__WEBPACK_IMPORTED_MODULE_2__[\"default\"].toPointList(d);\n                options = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({\n                  travelMode: google.maps.TravelMode.DRIVING,\n                  avoidFerries: undefined,\n                  avoidHighways: undefined,\n                  avoidTolls: undefined,\n                  unitSystem: google.maps.UnitSystem.METRIC\n                }, options);\n                var service = new google.maps.DistanceMatrixService();\n                service.getDistanceMatrix(options, function (response, status) {\n                  var err = null;\n\n                  if (status !== google.maps.DistanceMatrixStatus.OK) {\n                    err = _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromResponse(status) || _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromResponse(response);\n                    response = null;\n                  } else {\n                    response = options.raw ? response : _geo_helper__WEBPACK_IMPORTED_MODULE_2__[\"default\"].formatDistanceResults(response);\n                  }\n\n                  callback(err, response);\n                });\n              });\n            }\n            /**\n             *  Calculates the distance between two geographic points.\n             *\n             *  @param {Object} options\n             *         Calculation and display options.\n             *      @param {Object} options.from\n             *             Object containing the `latitude` and `longitude` of original\n             *             location.\n             *      @param {Object} options.to\n             *             Object containing the `latitude` and `longitude` of destination.\n             *      @param {String} [options.formula=\"haversine\"]\n             *             The algorithm or formula to calculate the distance.\n             *             See {@link #geolocator.DistanceFormula|`geolocator.DistanceFormula` enumeration}.\n             *      @param {Number} [options.unitSystem=0]\n             *             Preferred unit system to use when displaying distance.\n             *             See {@link #geolocator.UnitSystem|`geolocator.UnitSystem` enumeration}.\n             *\n             *  @returns {Number} - The calculated distance.\n             *\n             *  @example\n             *  // Calculate distance from London to Paris.\n             *  var result = geolocator.calcDistance({\n             *      from: {\n             *          latitude: 51.5085300,\n             *          longitude: -0.1257400\n             *      },\n             *      to: {\n             *          latitude: 48.8534100,\n             *          longitude: 2.3488000\n             *      },\n             *      formula: geolocator.DistanceFormula.HAVERSINE,\n             *      unitSystem: geolocator.UnitSystem.METRIC\n             *  });\n             *  // result: 366.41656039126093 (kilometers)\n             */\n\n          }, {\n            key: 'calcDistance',\n            value: function calcDistance(options) {\n              options = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({\n                formula: geolocator.DistanceFormula.HAVERSINE,\n                unitSystem: geolocator.UnitSystem.METRIC\n              }, options);\n              var from = options.from,\n                  to = options.to,\n                  radius = options.unitSystem === geolocator.UnitSystem.METRIC ? EARTH_RADIUS_KM : EARTH_RADIUS_MI;\n\n              if (options.formula === geolocator.DistanceFormula.HAVERSINE) {\n                var dLat = geolocator.degToRad(to.latitude - from.latitude),\n                    dLng = geolocator.degToRad(to.longitude - from.longitude),\n                    a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(geolocator.degToRad(from.latitude)) * Math.cos(geolocator.degToRad(to.longitude)) * Math.sin(dLng / 2) * Math.sin(dLng / 2),\n                    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n                return radius * c;\n              } // geolocator.DistanceFormula.PYTHAGOREAN\n\n\n              var latA = geolocator.degToRad(from.latitude),\n                  latB = geolocator.degToRad(to.latitude),\n                  lngA = geolocator.degToRad(from.longitude),\n                  lngB = geolocator.degToRad(to.longitude),\n                  x = (lngB - lngA) * Math.cos((latA + latB) / 2),\n                  y = latB - latA;\n              return Math.sqrt(x * x + y * y) * radius;\n            }\n            /**\n             *  Gets the current public IP of the client.\n             *\n             *  @param {Function} callback\n             *         Callback function to be executed when the request completes, in\n             *         the following signature: `function (err, result) { ... }`\n             *\n             *  @returns {void}\n             *\n             *  @example\n             *  geolocator.getIP(function (err, result) {\n             *      console.log(err || result);\n             *  });\n             *\n             *  @example\n             *  // result:\n             *  {\n             *      ip: \"176.232.71.155\",\n             *      timestamp: 1457573683427\n             *  }\n             */\n\n          }, {\n            key: 'getIP',\n            value: function getIP(callback) {\n              var conf = geolocator._.config; // ipify.org supports CORS, so we'll use XMLHttpRequest instead of a\n              // JSONP request.\n\n              var opts = {\n                url: _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setProtocol(_enums__WEBPACK_IMPORTED_MODULE_5__[\"default\"].URL.IP, conf.https),\n                async: true\n              };\n              return _lib_fetch__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(opts, function (err, xhr) {\n                var response = xhr.responseText;\n\n                if (err) {\n                  return callback(_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(err), null);\n                }\n\n                if (!response) {\n                  err = new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.INVALID_RESPONSE);\n                  return callback(err, null);\n                }\n\n                callback(null, {\n                  ip: response,\n                  timestamp: _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].time()\n                });\n              }); // let jsonpOpts = {\n              //     url: utils.setProtocol(enums.URL.IP, conf.https),\n              //     async: true,\n              //     clean: true,\n              //     params: {\n              //         format: 'jsonp'\n              //     },\n              //     callbackParam: 'callback',\n              //     rootName: 'geolocator._.cb'\n              // };\n              // return fetch.jsonp(jsonpOpts, (err, response) => {\n              //     if (err) {\n              //         return callback(GeoError.create(err), null);\n              //     }\n              //     if (!response) {\n              //         err = new GeoError(GeoError.Code.INVALID_RESPONSE);\n              //         return callback(err, null);\n              //     }\n              //     if (typeof response === 'object') response.timestamp = utils.time();\n              //     callback(null, response);\n              // });\n            }\n            /**\n             *  Ensures Google Maps API is loaded. If not, this will load all of the\n             *  main Javascript objects and symbols for use in the Maps API.\n             *\n             *  Note that, Google Maps API is loaded only when needed. For example,\n             *  the DistanceMatrix API does not support Web Service requests and\n             *  requires this API to be loaded. However, the TimeZone API requests are\n             *  made throught the Web Service without requiring a `google` object\n             *  within DOM.\n             *\n             *  Also note that this will not re-load the API if `google.maps` object\n             *  already exists. In this case, the `callback` is still executed and\n             *  no errors are passed.\n             *\n             *  You can use the following overload to omit the `key` argument altogether:\n             *\n             *  `geolocator.ensureGoogleLoaded(callback)`\n             *\n             *  @param {String} [key]\n             *         Google API key.\n             *  @param {Function} callback\n             *         Callback function to be executed when the operation ends.\n             *\n             *  @returns {void}\n             *\n             *  @example\n             *  geolocator.ensureGoogleLoaded(function (err) {\n             *      if (err) return;\n             *      console.log('google' in window); // true\n             *  });\n             */\n\n          }, {\n            key: 'ensureGoogleLoaded',\n            value: function ensureGoogleLoaded(key, callback) {\n              var k = void 0;\n\n              if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFunction(key)) {\n                callback = key;\n              } else {\n                k = key;\n              }\n\n              if (!geolocator.isGoogleLoaded()) {\n                var jsonpOpts = {\n                  url: _enums__WEBPACK_IMPORTED_MODULE_5__[\"default\"].URL.GOOGLE_MAPS_API,\n                  async: true,\n                  callbackParam: 'callback',\n                  params: {\n                    key: k || '' // callback: ''\n\n                  },\n                  rootName: 'geolocator._.cb'\n                };\n                return _lib_fetch__WEBPACK_IMPORTED_MODULE_1__[\"default\"].jsonp(jsonpOpts, callback);\n              }\n\n              callback();\n            }\n            /**\n             *  Checks whether the Google Maps API is loaded.\n             *\n             *  @returns {Boolean} - Returns `true` if already loaded.\n             */\n\n          }, {\n            key: 'isGoogleLoaded',\n            value: function isGoogleLoaded() {\n              return 'google' in window && google.maps;\n            }\n            /**\n             *  Checks whether the type of the given object is an HTML5 `PositionError`.\n             *\n             *  @param {*} obj - Object to be checked.\n             *  @return {Boolean}\n             */\n\n          }, {\n            key: 'isPositionError',\n            value: function isPositionError(obj) {\n              return _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPositionError(obj);\n            }\n            /**\n             *  Checks whether the given value is an instance of `GeoError`.\n             *\n             *  @param {*} obj - Object to be checked.\n             *  @return {Boolean}\n             */\n\n          }, {\n            key: 'isGeoError',\n            value: function isGeoError(obj) {\n              return _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isGeoError(obj);\n            }\n            /**\n             *  Checks whether HTML5 Geolocation API is supported.\n             *\n             *  @return {Boolean}\n             */\n\n          }, {\n            key: 'isGeolocationSupported',\n            value: function isGeolocationSupported() {\n              return navigator && 'geolocation' in navigator;\n            }\n            /**\n             *  Converts kilometers to miles.\n             *\n             *  @param {Number} km - Kilometers to be converted.\n             *  @returns {Number} - Miles.\n             */\n\n          }, {\n            key: 'kmToMi',\n            value: function kmToMi(km) {\n              return km * 0.621371;\n            }\n            /**\n             *  Converts miles to kilometers.\n             *\n             *  @param {Number} mi - Miles to be converted.\n             *  @returns {Number} - Kilometers.\n             */\n\n          }, {\n            key: 'miToKm',\n            value: function miToKm(mi) {\n              return mi / 0.621371;\n            }\n            /**\n             *  Converts degrees to radians.\n             *\n             *  @param {Number} deg - Degrees to be converted.\n             *  @returns {Number} - Radians.\n             */\n\n          }, {\n            key: 'degToRad',\n            value: function degToRad(degrees) {\n              return degrees * (Math.PI / 180);\n            }\n            /**\n             *  Converts radians to degrees.\n             *\n             *  @param {Number} rad - Radians to be converted.\n             *  @returns {Number} - Degrees.\n             */\n\n          }, {\n            key: 'radToDeg',\n            value: function radToDeg(radians) {\n              return radians * (180 / Math.PI);\n            }\n            /**\n             *  Converts decimal coordinates (either lat or lng) to degrees, minutes, seconds.\n             *\n             *  @param {Number} dec\n             *         Decimals to be converted.\n             *  @param {Boolean} [isLng=false]\n             *         Indicates whether the given decimals is longitude.\n             *\n             *  @returns {String} - Degrees, minutes, seconds.\n             */\n\n          }, {\n            key: 'decToDegMinSec',\n            value: function decToDegMinSec(dec) {\n              var isLng = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // Degrees Latitude must be in the range of -90. to 90.\n              // Degrees Longitude must be in the range of -180 to 180.\n              // +Latitude is North, -Latitude is South\n              // +Longitude is East, -Longitude is West\n\n              var sign = dec < 0 ? -1 : 1,\n                  sn = dec < 0 ? 'S' : 'N',\n                  we = dec < 0 ? 'W' : 'E',\n                  nsew = !isLng ? sn : we,\n                  absValue = Math.abs(Math.round(dec * 1000000.0));\n              return Math.floor(absValue / 1000000) * sign + '° ' + Math.floor((absValue / 1000000 - Math.floor(absValue / 1000000)) * 60) + '\\' ' + Math.floor(((absValue / 1000000 - Math.floor(absValue / 1000000)) * 60 - Math.floor((absValue / 1000000 - Math.floor(absValue / 1000000)) * 60)) * 100000) * 60 / 100000 + '\" ' + nsew;\n            }\n          }, {\n            key: 'Error',\n            // ---------------------------\n            // PROPERTIES\n            // ---------------------------\n\n            /**\n             *  Geolocator Error class that provides a common type of error object for\n             *  the various APIs implemented in Geolocator. All callbacks of Geolocator\n             *  will include an instance of this object as the first argument; if the\n             *  corresponding operation fails. Also all thrown errors will be an instance\n             *  of this object.\n             *\n             *  This object also enumerates\n             *  {@link ?api=geolocator-error#GeoError.Code|Geolocator Error codes}.\n             *\n             *  @see {@link ?api=geolocator-error|`GeoError` documentation}\n             *  @type {GeoError}\n             *  @readonly\n             */\n            get: function get() {\n              return _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n            }\n            /**\n             *  Documented separately in enums.js\n             *  @private\n             */\n\n          }, {\n            key: 'MapTypeId',\n            get: function get() {\n              return _enums__WEBPACK_IMPORTED_MODULE_5__[\"default\"].MapTypeId;\n            }\n            /**\n             *  Documented separately in enums.js\n             *  @private\n             */\n\n          }, {\n            key: 'LocationType',\n            get: function get() {\n              return _enums__WEBPACK_IMPORTED_MODULE_5__[\"default\"].LocationType;\n            }\n            /**\n             *  Documented separately in enums.js\n             *  @private\n             */\n\n          }, {\n            key: 'TravelMode',\n            get: function get() {\n              return _enums__WEBPACK_IMPORTED_MODULE_5__[\"default\"].TravelMode;\n            }\n            /**\n             *  Documented separately in enums.js\n             *  @private\n             */\n\n          }, {\n            key: 'UnitSystem',\n            get: function get() {\n              return _enums__WEBPACK_IMPORTED_MODULE_5__[\"default\"].UnitSystem;\n            }\n            /**\n             *  Documented separately in enums.js\n             *  @private\n             */\n\n          }, {\n            key: 'RadioType',\n            get: function get() {\n              return _enums__WEBPACK_IMPORTED_MODULE_5__[\"default\"].RadioType;\n            }\n            /**\n             *  Documented separately in enums.js\n             *  @private\n             */\n\n          }, {\n            key: 'DistanceFormula',\n            get: function get() {\n              return _enums__WEBPACK_IMPORTED_MODULE_5__[\"default\"].DistanceFormula;\n            }\n            /**\n             *  Documented separately in enums.js\n             *  @private\n             */\n\n          }, {\n            key: 'ImageFormat',\n            get: function get() {\n              return _enums__WEBPACK_IMPORTED_MODULE_5__[\"default\"].ImageFormat;\n            }\n          }]);\n\n          return geolocator;\n        }(); // ---------------------------\n        // HELPER METHODS\n        // ---------------------------\n\n        /**\n         *  Used with distance matrix calls.\n         *  @private\n         */\n\n\n        function invalidOriginOrDest(value) {\n          return !_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(value) && !_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(value) && !_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(value);\n        }\n        /**\n         *  Check if XHR response is an error response and returns a `GeoError`.\n         *  If not, returns the parsed response.\n         *  @private\n         *\n         *  @param {Error} err\n         *         XHR error.\n         *  @param {Object} xhr\n         *         XHR object to be checked.\n         *\n         *  @returns {GeoError|Object}\n         */\n\n\n        function getXHRResponse(err, xhr) {\n          if (err) return _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(err);\n          if (!xhr) return new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.REQUEST_FAILED);\n\n          var response = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].safeJsonParse(xhr.responseText); // Check if XHR response is an error response.\n          // return response if not.\n\n\n          return _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromResponse(response) || response;\n        }\n        /**\n         *  Checks the given options and determines if Google key is required.\n         *  Throws if key is required but not set or valid.\n         *  @private\n         *\n         *  @param {Object} [options]\n         *         Options to be checked. If `undefined`, directly checks Googke key.\n         */\n\n\n        function checkGoogleKey(options) {\n          if (!options || options.addressLookup || options.timezone || options.map || options.staticMap) {\n            if (!geolocator._.config.google.key) {\n              throw new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.GOOGLE_KEY_INVALID, 'A Google API key is required but it\\'s not set or valid.');\n            }\n          }\n        }\n        /**\n         *  Checks and adds necessary properties to map options from the given location\n         *  result object. This is used with methods that support `map` option; to\n         *  create a map from the result coordinates; such as locate() method.\n         *  @private\n         *\n         *  @param {Object|String} options\n         *         Original options object.\n         *  @param {Object} location\n         *         Location result object.\n         *\n         *  @returns {Object} - Final map options object.\n         */\n\n\n        function getMapOpts(mapOptions, location) {\n          if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject(mapOptions)) {\n            mapOptions.center = location.coords;\n          } else {\n            mapOptions = {\n              element: mapOptions,\n              center: location.coords\n            };\n          } // this will enable infoWindow\n\n\n          if (location.formattedAddress) {\n            mapOptions.title = location.formattedAddress;\n          } // if location has accuracy, (and zoom is not set) we can zoom in a bit more\n\n\n          if (!mapOptions.zoom && location.coords && _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber(location.coords.accuracy) && location.coords.accuracy < 1500) {\n            mapOptions.zoom = 15;\n          }\n\n          return mapOptions;\n        }\n        /**\n         *  Checks the HTMLElement to see whether a previous map and related objects\n         *  (marker, infoWindow) are created for it; by checking our private property\n         *  `_geolocatorMapData`. If there is a map, this does not re-create it (which\n         *  will break the map) but only re-adjust center, zoom and re-create the marker\n         *  if needed. We use this approach bec. Google maps has no feature to destroy\n         *  a map. This is considered a bug by Google developers.\n         *  @private\n         *\n         *  @param {Object} options\n         *         Options for creating a map.\n         */\n\n\n        function configCreateMap(options) {\n          var elem = options.element,\n              // when geolocator creates a map, it will set a `_geolocatorMapData`\n          // property on the element. So we can use this map instance later,\n          // when the same HTMLElement is passed to create a map. So check if\n          // we have it here.\n          mapData = elem._geolocatorMapData,\n              map = mapData && mapData.instance || null,\n              marker = mapData && mapData.marker || null,\n              infoWindow = mapData && mapData.infoWindow || null,\n              center = new google.maps.LatLng(options.center.latitude, options.center.longitude),\n              mapOptions = {\n            mapTypeId: options.mapTypeId,\n            center: center,\n            zoom: options.zoom,\n            styles: options.styles || null\n          }; // if we have a map, we'll just configure it. otherwise, we'll create\n          // one.\n\n          if (map) {\n            map.setOptions(mapOptions);\n          } else {\n            map = new google.maps.Map(options.element, mapOptions);\n          } // destroy marker and infoWindow if previously created for this element.\n\n\n          if (infoWindow) infoWindow = null;\n\n          if (marker && marker instanceof google.maps.Marker) {\n            google.maps.event.clearInstanceListeners(marker);\n            marker.setMap(null);\n            marker = null;\n          } // check the new options to see if we need to re-create a marker for\n          // this.\n\n\n          if (options.marker) {\n            marker = new google.maps.Marker({\n              position: mapOptions.center,\n              map: map\n            });\n\n            if (options.title) {\n              infoWindow = new google.maps.InfoWindow();\n              infoWindow.setContent(options.title); // infoWindow.open(map, marker);\n\n              google.maps.event.addListener(marker, 'click', function () {\n                infoWindow.open(map, marker);\n              });\n            }\n          }\n\n          mapData = {\n            element: elem,\n            instance: map,\n            marker: marker,\n            infoWindow: infoWindow,\n            options: mapOptions\n          }; // set the reference on the element for later use, if needed.\n\n          elem._geolocatorMapData = mapData;\n          return mapData;\n        }\n        /**\n         *  Sets the `flag` and `staticMap` (if enabled) property of the given location.\n         *  @private\n         *\n         *  @param {Object} location - Fetched location result.\n         *  @param {Object} options - initial options.\n         */\n\n\n        function setLocationURLs(location, options) {\n          if (!location || !location.address) return;\n          var cc = void 0,\n              address = location.address;\n\n          if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(address.countryCode) && address.countryCode.length === 2) {\n            cc = address.countryCode;\n          } else if (_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(address.country) && address.country.length === 2) {\n            cc = address.country;\n          }\n\n          if (!cc) return;\n          location.flag = _enums__WEBPACK_IMPORTED_MODULE_5__[\"default\"].URL.FLAG + cc.toLowerCase() + '.svg';\n\n          if (options.staticMap) {\n            var opts = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(options.staticMap) ? _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clone(options.staticMap) : {};\n            opts.center = location.coords;\n            location.staticMap = geolocator.getStaticMap(opts);\n          }\n        }\n        /**\n         *  Nests `createMap` callback within the given callback.\n         *  @private\n         *\n         *  @param {Object} options\n         *         Method options.\n         *  @param {Function} callback\n         *         Parent callback.\n         *\n         *  @returns {Function} - Nested callback.\n         */\n\n\n        function callbackMap(options, callback) {\n          return function cb(err, location) {\n            if (err) return callback(_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(err), null);\n            setLocationURLs(location, options);\n            if (!options.map) return callback(null, location);\n            options.map = getMapOpts(options.map, location);\n            geolocator.createMap(options.map, function (error, map) {\n              if (error) return callback(error, null);\n              location.map = map;\n              return callback(null, location);\n            });\n          };\n        }\n        /**\n         *  Sends a geocode or reverse-geocode request with the given options.\n         *  @private\n         *\n         *  @param {Boolean} reverse\n         *         Whether to send reverse-geocode request.\n         *  @param {Object} options\n         *         Geocode options.\n         *  @param {Function} callback\n         *         Callback to be nested and executed with map callback.\n         */\n\n\n        function _geocode(reverse, options, callback) {\n          checkGoogleKey();\n\n          _geo_helper__WEBPACK_IMPORTED_MODULE_2__[\"default\"].geocode(reverse, geolocator._.config, options, callbackMap(options, callback));\n        }\n        /**\n         *  Runs both an address and a timezone look-up for the given location.\n         *  @private\n         *\n         *  @param {Object} location\n         *         Location object.\n         *  @param {Object} options\n         *         Method options.\n         *  @param {Function} callback\n         *         Parent callback.\n         */\n\n\n        function fetchAddressAndTimezone(location, options, callback) {\n          var loc = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clone(location, {\n            own: false\n          });\n\n          if (!options.addressLookup && !options.timezone) {\n            return callback(null, loc);\n          }\n\n          function getTZ(cb) {\n            geolocator.getTimeZone(loc.coords, function (err, timezone) {\n              if (err) {\n                return cb(err, null);\n              }\n\n              delete timezone.timestamp;\n              loc.timezone = timezone;\n              loc.timestamp = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].time(); // update timestamp\n\n              cb(null, loc);\n            });\n          }\n\n          if (options.addressLookup) {\n            geolocator.reverseGeocode(loc.coords, function (err, result) {\n              if (err) return callback(err, null);\n              loc = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({}, result, loc);\n              loc.address = result.address;\n              loc.timestamp = _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].time(); // update timestamp\n\n              if (!options.timezone) {\n                callback(err, loc);\n              } else {\n                getTZ(callback);\n              }\n            });\n          } else if (options.timezone) {\n            getTZ(callback);\n          } else {\n            callback(null, loc);\n          }\n        }\n        /**\n         *  Gets the position with better accuracy.\n         *  See https://github.com/gwilson/getAccurateCurrentPosition#background\n         *  @private\n         *\n         *  @param {Object} options\n         *         Locate options.\n         *  @param {Function} onPositionReceived\n         *         Success callback.\n         *  @param {Function} onPositionError\n         *         Error callback.\n         */\n\n\n        function locateAccurate(options, onPositionReceived, onPositionError) {\n          var loc = void 0,\n              watcher = void 0,\n              onProgress = !_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFunction(options.onProgress) ? _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop : options.onProgress;\n\n          function complete() {\n            watcher = null;\n\n            if (!loc) {\n              onPositionError(new _geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_geo_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Code.POSITION_UNAVAILABLE));\n            } else {\n              onPositionReceived(loc);\n            }\n          }\n\n          watcher = geolocator.watch(options, function (err, location) {\n            if (!watcher) return;\n\n            if (err) {\n              return watcher.clear(function () {\n                onPositionError(err);\n              });\n            }\n\n            loc = location; // ignore the first event if not the only result; for more accuracy.\n\n            if (watcher.cycle > 1 && loc.coords.accuracy <= options.desiredAccuracy) {\n              watcher.clear(complete);\n            } else {\n              onProgress(loc);\n            }\n          });\n          if (watcher) watcher.clear(options.maximumWait + 100, complete);\n        }\n\n        function getStyles(options) {\n          var conf = geolocator._.config;\n          return !_lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFilledArray(options.styles) ? _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFilledArray(conf.google.styles) ? conf.google.styles : null : options.styles;\n        } // ---------------------------\n        // INITIALIZE\n        // ---------------------------\n\n        /**\n         *  @private\n         *  @type {Object}\n         */\n\n\n        geolocator._ = {\n          config: _lib_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({}, defaultConfig),\n          // Storage for global callbacks.\n          cb: {}\n        }; // setting default Geo-IP source\n\n        geolocator.setGeoIPSource({\n          provider: 'geojs.io',\n          url: 'https://get.geojs.io/v1/ip/geo.json',\n          xhr: true,\n          schema: {\n            ip: 'ip',\n            coords: {\n              latitude: 'latitude',\n              longitude: 'longitude'\n            },\n            address: {\n              city: 'city',\n              state: 'region',\n              stateCode: '',\n              postalCode: '',\n              countryCode: 'country_code',\n              country: 'country',\n              region: 'region'\n            },\n            timezone: {\n              id: 'timezone'\n            }\n          }\n        }); // ---------------------------\n        // EXPORT\n        // ---------------------------\n        // ---------------------------\n        // ADDITIONAL DOCUMENTATION\n        // ---------------------------\n\n        /**\n         *  `Coordinates` inner type that specifies the geographic position of the\n         *  device. The position is expressed as a set of geographic coordinates\n         *  together with information about heading and speed.\n         *\n         *  This is generally returned as part of the\n         *  {@link ?api=geolocator#geolocator~Location|`Location` result object}.\n         *\n         *  @typedef geolocator~Coordinates\n         *  @type Object\n         *\n         *  @property {Number} latitude\n         *         Specifies the latitude estimate in decimal degrees. The value\n         *         range is [-90.00, +90.00].\n         *  @property {Number} longitude\n         *         Specifies the longitude estimate in decimal degrees. The value\n         *         range is [-180.00, +180.00].\n         *  @property {Number} altitude\n         *         Specifies the altitude estimate in meters above the WGS 84\n         *         ellipsoid.\n         *  @property {Number} accuracy\n         *         Specifies the accuracy of the latitude and longitude estimates in\n         *         meters.\n         *  @property {Number} altitudeAccuracy\n         *         Specifies the accuracy of the altitude estimate in meters.\n         *  @property {Number} heading\n         *         Specifies the device's current direction of movement in degrees\n         *         counting clockwise relative to true north.\n         *  @property {Number} speed\n         *         Specifies the device's current ground speed in meters per second.\n         */\n\n        /**\n         *\t`Address` inner type that specifies the address of the fetched location.\n         *\tThe address is expressed as a set of political and locality components.\n         *\n         *  This is generally returned as part of the\n         *  {@link ?api=geolocator#geolocator~Location|`Location` result object}.\n         *\n         *  @typedef geolocator~Address\n         *  @type Object\n         *\n         *  @property {String} commonName\n         *         Indicates a point of interest, a premise or colloquial area name for\n         *         the fetched location, if any.\n         *  @property {String} streetNumber\n         *         Indicates the precise street number of the fetched location, if any.\n         *  @property {String} street\n         *         Indicates the street name of the fetched location, if any.\n         *  @property {String} route\n         *         Indicates the route name of the fetched location, if any.\n         *  @property {String} neighborhood\n         *         Indicates the neighborhood name of the fetched location, if any.\n         *  @property {String} town\n         *         Indictes the town of the fetched location, if any.\n         *  @property {String} city\n         *         Indicates the city of the fetched location.\n         *  @property {String} region\n         *         Indicates the political region name of the fetched location, if any.\n         *  @property {String} postalCode\n         *         Indicates the postal code of the fetched location, if any.\n         *  @property {String} state\n         *         Indicates the state of the fetched location, if any.\n         *  @property {String} stateCode\n         *         Indicates the state code of the fetched location, if any.\n         *  @property {String} country\n         *         Indicates the national political entity of the fetched location.\n         *  @property {String} countryCode\n         *         Indicates the ISO alpha-2 country code of the fetched location.\n         */\n\n        /**\n         *\t`TimeZone` inner type that specifies time offset data for the fetched\n         *\tlocation on the surface of the earth.\n         *\n         *  This is generally returned as part of the\n         *  {@link ?api=geolocator#geolocator~Location|`Location` result object}.\n         *\n         *  @typedef geolocator~TimeZone\n         *  @type Object\n         *\n         *  @property {String} id\n         *         The ID of the time zone, such as `\"America/Los_Angeles\"` or\n         *         `\"Australia/Sydney\"`. These IDs are defined in the\n         *         {@link http://www.iana.org/time-zones|IANA Time Zone Database},\n         *         which is also available in searchable format in Wikipedia's\n         *         {@link http://en.wikipedia.org/wiki/List_of_tz_database_time_zones|List of tz database time zones}.\n         *  @property {String} name\n         *         The long form name of the time zone. This field will be localized if\n         *         the Geolocator `language` is configured. e.g. `\"Pacific Daylight Time\"`\n         *         or `\"Australian Eastern Daylight Time\"`.\n         *  @property {String} abbr\n         *         The abbreviation of the time zone.\n         *  @property {Number} dstOffset\n         *         The offset for daylight-savings time in seconds. This will be zero\n         *         if the time zone is not in Daylight Savings Time during the specified\n         *         timestamp.\n         *  @property {Number} rawOffset\n         *         The offset from UTC (in seconds) for the given location. This does\n         *         not take into effect daylight savings.\n         */\n\n        /**\n         *\t`MapData` inner type that provides references to the components of a\n         *\tcreated Google Maps `Map` and the containing DOM element.\n         *\n         *  This is generally returned as part of the\n         *  {@link ?api=geolocator#geolocator~Location|`Location` result object}.\n         *\n         *  @typedef geolocator~MapData\n         *  @type Object\n         *\n         *  @property {HTMLElement} element\n         *         DOM element which a (Google) map is created within.\n         *  @property {google.maps.Map} instance\n         *         Instance of a Google Maps `Map` object.\n         *  @property {google.maps.Marker} marker\n         *         Instance of a Google Maps `Marker` object, if any.\n         *  @property {google.maps.InfoWindow} infoWindow\n         *         Instance of a Google Maps `InfoWindow` object, if any.\n         *  @property {Object} options\n         *         Arbitrary object of applied map options.\n         */\n\n        /**\n         *\t`Location` inner type that specifies geographic coordinates, address and\n         *\ttime zone information for the fetched location.\n         *\n         *  This result object is passed to the callbacks of the corresponding\n         *  asynchronous Geolocator methods (such as `.locate()` method), as the second\n         *  argument. The contents of this object will differ for various  Geolocator\n         *  methods, depending on the configured method options.\n         *\n         *  @typedef geolocator~Location\n         *  @type Object\n         *\n         *  @property {Coordinates} coords\n         *         Specifies the geographic location of the device. The location is\n         *         expressed as a set of geographic coordinates together with\n         *         information about heading and speed.\n         *         See {@link #geolocator~Coordinates|`geolocator~Coordinates` type}\n         *         for details.\n         *  @property {Address} address\n         *         Specifies the address of the fetched location. The address is\n         *         expressed as a set of political and locality components.\n         *         This property might be `undefined` if `addressLookup` option is not\n         *         enabled for the corresponding method.\n         *         See {@link #geolocator~Address|`geolocator~Address` type}\n         *         for details.\n         *  @property {String} formattedAddress\n         *         The human-readable address of this location. Often this address is\n         *         equivalent to the \"postal address,\" which sometimes differs from\n         *         country to country.\n         *  @property {Boolean} targetReached\n         *         Specifies whether the defined target coordinates is reached.\n         *         This property is only available for\n         *         {@link #geolocator.watch|`geolocator.watch()`} method when `target`\n         *         option is defined.\n         *  @property {String} type\n         *         Type of the location. See\n         *         {@link #geolcoator.LocationType|`geolcoator.LocationType` enumeration}\n         *         for details.\n         *  @property {String} placeId\n         *         A unique identifier that can be used with other Google APIs.\n         *  @property {String} flag\n         *         URL of the country flag image, in SVG format. This property exists\n         *         only if address information is available.\n         *  @property {TimeZone} timezone\n         *         Specifies time offset data for the fetched location on the surface of\n         *         the earth. See {@link #geolocator~TimeZone|`geolocator~TimeZone` type}\n         *         for details.\n         *  @property {MapData} map\n         *         Provides references to the components of a created Google Maps `Map`\n         *         and the containing DOM element. See\n         *         {@link #geolocator~MapData|`geolocator~MapData` type} for details.\n         *  @property {String} staticMap\n         *         URL of a static Google map image, for the location.\n         *  @property {Number} timestamp\n         *         Specifies the time when the location information was retrieved and\n         *         the `Location` object created.\n         */\n\n        /**\n         *  `MapOptions` inner type that specifies options for the map to be created.\n         *\n         *  @typedef geolocator~MapOptions\n         *  @type Object\n         *\n         *  @property {String|HTMLElement|Map} element\n         *         Either the ID of a DOM element or the element itself;\n         *         which the map will be created within; or a previously created\n         *         `google.maps.Map` instance. If a map instance is set, this\n         *         only will apply the options without re-creating it.\n         *  @property {Object} center\n         *         Center coordinates for the map to be created.\n         *      @property {Number} center.latitude\n         *             Latitude of the center point coordinates.\n         *      @property {Number} center.longitude\n         *             Longitude of the center point coordinates.\n         *  @property {String} mapTypeId\n         *         Type of the map to be created.\n         *         See {@link #geolocator.MapTypeId|`geolocator.MapTypeId` enumeration}\n         *         for possible values.\n         *  @property {String} title\n         *         Title text to be displayed within an `InfoWindow`, when the\n         *         marker is clicked. This only take effect if `marker` is\n         *         enabled.\n         *  @property {Boolean} marker\n         *         Whether to place a marker at the given coordinates.\n         *         If `title` is set, an `InfoWindow` will be opened when the\n         *         marker is clicked.\n         *  @property {Number} zoom\n         *             Zoom level to be set for the map.\n         */\n\n        /***/\n      },\n\n      /***/\n      \"./src/index.js\":\n      /*!**********************!*\\\n        !*** ./src/index.js ***!\n        \\**********************/\n\n      /*! no static exports found */\n\n      /***/\n      function (module, exports, __webpack_require__) {\n        // we don't mix import and module.exports in same file, so using require here.\n        var geolocator = __webpack_require__(\n        /*! ./core/geolocator */\n        \"./src/core/geolocator.js\").geolocator; // See https://github.com/onury/geolocator/issues/42\n\n\n        if (typeof window !== 'undefined' && typeof window.geolocator === 'undefined') {\n          window.geolocator = geolocator;\n        } // export default geolocator;\n        // http://stackoverflow.com/a/33683495/112731\n\n\n        module.exports = geolocator;\n        /***/\n      },\n\n      /***/\n      \"./src/lib/fetch.js\":\n      /*!**************************!*\\\n        !*** ./src/lib/fetch.js ***!\n        \\**************************/\n\n      /*! exports provided: default */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        \"use strict\";\n\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony import */\n\n\n        var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n        /*! ./utils */\n        \"./src/lib/utils.js\");\n\n        var _createClass = function () {\n          function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n\n          return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n          };\n        }();\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n        /**\n         * Utility for making `XMLHttpRequest` and `JSONP` requests.\n         * @copyright 2019, Onur Yıldırım <onur@cutepilot.com>\n         */\n\n\n        var fetch = function () {\n          function fetch() {\n            _classCallCheck(this, fetch);\n          }\n\n          _createClass(fetch, null, [{\n            key: 'jsonp',\n            // https://html.spec.whatwg.org/multipage/scripting.html#script\n\n            /**\n             * Makes a JSONP (GET) request by injecting a script tag in the browser.\n             * Note that using JSONP has some security implications. As JSONP is really\n             * javascript, it can do everything else javascript can do, so you need to\n             * trust the provider of the JSONP data.\n             * @see https://en.wikipedia.org/wiki/JSONP\n             * @memberof fetch\n             *\n             * @param {Object|String} options - Required. Either the URL string which\n             *     will set other options to defaults or an options object with the\n             *     following properties.\n             *     @param {String} options.url\n             *            Source URL to be called.\n             *     @param {String} [options.type]\n             *            The MIME type that identifies the scripting language of the\n             *            code referenced within the script element.\n             *            e.g. `\"text/javascript\"`\n             *     @param {String} [options.charset]\n             *            Indicates the character encoding of the external resource.\n             *            e.g. `\"utf-8\"`.\n             *     @param {Boolean} [options.async=true]\n             *            Indicates whether or not to perform the operation\n             *            asynchronously. See {@link http://caniuse.com/#feat=script-async|browser support}.\n             *     @param {Boolean} [options.defer=false]\n             *            Indicates whether the script should be executed when the page\n             *            has finished parsing. See {@link http://caniuse.com/#feat=script-defer|browser support}.\n             *     @param {String} [options.crossorigin]\n             *            Indicates the CORS setting for the script element being\n             *            injected. Note that this attribute is not widely supported.\n             *            Valid values: `\"anonymous\"`, `\"use-credentials\"`.\n             *            See {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes|CORS settings}.\n             *     @param {Number} [options.timeout=0]\n             *            The number of milliseconds a request can take before\n             *            automatically being terminated. `0` disables timeout.\n             *     @param {Boolean} [options.clean=false]\n             *            Whether to remove the loaded script from DOM when the\n             *            operation ends. Note that the initial source might load\n             *            additional sources which are not deteceted or removed. Only\n             *            the initial source is removed.\n             *     @param {Object} [options.params]\n             *            Optional query parameters to be appended at the end of the URL.\n             *            e.g. `{ key: \"MY-KEY\" }`\n             *            You can also include the JSONP callback name parameter here\n             *            but if you want the object to be passed to the callback\n             *            argument of this method, use `options.callbackParam` to set\n             *            the callback parameter.\n             *     @param {String} [options.callbackParam]\n             *            If the endpoint supports JSONP callbacks, you can set the\n             *            callback parameter with this setting. This will enable a\n             *            second `obj` argument in the callback of this method which is\n             *            useful if the JSONP source invokes the callback with an\n             *            argument.\n             *     @param {String} [options.rootName]\n             *            The name (or notation) of the object that the generated JSONP\n             *            callback function should be assigned to. By default, this is\n             *            the `window` object but you can set this to a custom object\n             *            notation; for example, to prevent global namespace polution.\n             *            Note that this root object has to be globally accessible for\n             *            this to work. e.g. `\"window.myObject\"` (as string)\n             * @param {Function} [callback]\n             *        The callback function that will be executed when the script is\n             *        loaded. This callback has the following signature:\n             *        `function (err, obj) { ... }`. Note that the second argument\n             *        `obj` will always be `undefined` if the source endpoint does not\n             *        support JSONP callbacks or a callback param is not set explicitly\n             *        via `options.callbackParam` (or if the source does not invoke the\n             *        jsonp with an argument). However, the function will always execute\n             *        when the script loads or an error occurs.\n             *\n             * @returns {void}\n             *\n             * @example\n             * var opts1 = {\n             * \t   url: 'some/api',\n             * \t   callbackParam: 'jsonCallback',\n             * \t   params: { key: 'MY-KEY' }\n             * };\n             * // This will load the following source:\n             * // some/api?jsonCallback={auto-generated-fn-name}&key=MY-KEY\n             * fetch.jsonp(opts1, function (err, obj) {\n             * \t   console.log(obj); // some object\n             * });\n             *\n             * var opts2 = {\n             * \t   url: 'some/api',\n             * \t   params: {\n             * \t\t   key: 'MY-KEY',\n             * \t\t   jsonCallback: 'my-fn-name'\n             * \t   }\n             * };\n             * // This will load the following source:\n             * // some/api?jsonCallback=my-fn-name&key=MY-KEY\n             * fetch.jsonp(options, function (err, obj) {\n             * \t   console.log(obj); // undefined\n             * \t   // still executes, catch errors here\n             * });\n             * // JSON callback should be explicitly set.\n             * window['my-fn-name'] = function (obj) {\n             * \t   console.log(obj); // some object\n             * };\n             */\n            value: function jsonp(options, callback) {\n              var timeout = void 0;\n              callback = _utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFunction(callback) ? callback : _utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop;\n\n              if (_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(options)) {\n                options = {\n                  url: options\n                };\n              }\n\n              if (_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(options)) {\n                options = _utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({\n                  // type: undefined,\n                  async: true,\n                  defer: false,\n                  // crossorigin: undefined,\n                  timeout: 0,\n                  params: {},\n                  // callbackParam: undefined,\n                  // rootName: undefined,\n                  clean: true\n                }, options);\n              } else {\n                return callback(new Error('No options or target URL is provided.'));\n              }\n\n              if (_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(options.url) === false || options.url.trim() === '') {\n                return callback(new Error('No target URL is provided.'));\n              }\n\n              var script = document.createElement('script'),\n                  cbParamSet = _utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(options.callbackParam) && options.callbackParam.trim() !== '',\n                  cbFnName = void 0,\n                  root = void 0,\n                  rootNameSet = _utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(options.rootName) && options.rootName !== 'window' && options.rootName !== 'document' && options.rootName.trim() !== '';\n\n              if (cbParamSet) {\n                cbFnName = '_jsonp_' + _utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomString(10);\n                options.params[options.callbackParam] = rootNameSet ? options.rootName + '.' + cbFnName : cbFnName;\n              }\n\n              var query = _utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].params(options.params) || '',\n                  qMark = options.url.indexOf('?') >= 0 ? '&' : '?',\n                  url = query ? '' + options.url + qMark + query : options.url; // console.log(url);\n\n              function execCb(err, timeUp, obj) {\n                if (timeout) {\n                  clearTimeout(timeout);\n                  timeout = null;\n                }\n\n                if ((timeUp || options.clean) && script.parentNode) {\n                  script.parentNode.removeChild(script);\n                } // delete the jsonp callback function\n\n\n                if (rootNameSet) {\n                  delete root[cbFnName];\n                }\n\n                callback(err, obj);\n              }\n\n              if (cbFnName) {\n                var fn = function fn(obj) {\n                  execCb(null, false, obj);\n                };\n\n                root = rootNameSet // ? window[options.rootName][cbFnName] = fn;\n                ? _utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].notateGlobalObj(options.rootName) // if rootName is dot-notation.\n                : window;\n                root[cbFnName] = fn;\n              } else if (script.readyState) {\n                // IE < 11\n                script.onreadystatechange = function () {\n                  if (script.readyState === 'loaded' || script.readyState === 'complete') {\n                    script.onreadystatechange = null;\n                    execCb(null);\n                  }\n                };\n              } else {\n                // IE 11+\n                script.onload = function () {\n                  execCb(null);\n                };\n              }\n\n              script.onerror = function (error) {\n                var errMsg = 'Could not load source at ' + _utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].removeQuery(options.url);\n\n                if (error) {\n                  errMsg += '\\n' + (error.message || error);\n                }\n\n                execCb(new Error(errMsg));\n              };\n\n              if (options.type) {\n                script.type = options.type;\n              }\n\n              if (options.charset) {\n                script.charset = options.charset;\n              }\n\n              if (options.async) {\n                script.async = true;\n              }\n\n              if (options.defer) {\n                script.defer = true;\n              }\n\n              if (options.crossorigin) {\n                script.crossorigin = options.crossorigin;\n              }\n\n              script.src = url;\n              document.getElementsByTagName('head')[0].appendChild(script); // Timeout\n\n              if (_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber(options.timeout) && options.timeout > 0) {\n                timeout = setTimeout(function () {\n                  script.src = '';\n                  execCb(new Error('Operation timed out.'), true);\n                }, options.timeout);\n              }\n            }\n            /**\n             * Makes an XMLHttpRequest with the given parameters.\n             * Note that `\"Access-Control-Allow-Origin\"` header should be present on\n             * the requested resource. Otherwise, the request will not be allowed.\n             * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest|XMLHttpRequest}.\n             * @memberof fetch\n             *\n             * @param {Object|String} options\n             *        Either the URL string which will set other options to defaults or\n             *        the full options object.\n             *     @param {String} options.url\n             *            Target URL to be called.\n             *     @param {String} [options.method=\"GET\"]\n             *            HTTP method.\n             *     @param {*} [options.data]\n             *            Data to be sent with the request.\n             *     @param {Number} [options.timeout]\n             *            The number of milliseconds a request can take before\n             *            automatically being terminated. `0` disables timeout.\n             *     @param {Boolean} [options.withCredentials=false]\n             *            Indicates whether or not cross-site Access-Control requests\n             *            should be made using credentials such as cookies or\n             *            authorization headers.\n             *     @param {Boolean} [options.async=true]\n             *            Indicating whether or not to perform the operation\n             *            asynchronously. If this value is false, the `send()` method\n             *            does not return until the response is received. If `true`,\n             *            notification of a completed transaction is provided using\n             *            event listeners. This must be `true` if the multipart\n             *            attribute is `true`, or an exception will be thrown.\n             *     @param {String} [options.mimeType]\n             *            If set, overrides the MIME type returned by the server. This\n             *            may be used, for example, to force a stream to be treated and\n             *            parsed as `text/xml`, even if the server does not report it as\n             *            such.\n             *     @param {Object} [options.headers]\n             *            Sets the HTTP request headers. Each key should be a header\n             *            name with a value. e.g. `{ 'Content-Length': 50 }`. For\n             *            security reasons, some headers cannot be set and can only be\n             *            controlled by the user agent.\n             *     @param {String} [options.username=\"\"]\n             *            User name to use for authentication purposes.\n             *     @param {String} [options.password=\"\"]\n             *            Password to use for authentication purposes.\n             * @param {Function} [callback]\n             *        The callback function in the following signature:\n             *        `function (err, xhr) { ... }`\n             *        Note that `xhr` object is always passed regardless of an error.\n             *\n             * @returns {void}\n             */\n\n          }, {\n            key: 'xhr',\n            value: function xhr(options, callback) {\n              var xhr = void 0,\n                  err = void 0;\n              var isXDR = false;\n\n              if ('XMLHttpRequest' in window) {\n                xhr = new XMLHttpRequest();\n              } else if ('XDomainRequest' in window) {\n                // IE9\n                xhr = new XDomainRequest();\n                isXDR = true;\n              } else {\n                throw new Error('XMLHttpRequest is not supported!');\n              }\n\n              var hasCallback = _utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFunction(callback);\n\n              callback = hasCallback ? callback : _utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop;\n              if (_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(options)) options = {\n                url: options\n              };\n\n              if (_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(options)) {\n                options = _utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({\n                  method: 'GET',\n                  data: undefined,\n                  async: true,\n                  timeout: 0,\n                  // no timeout\n                  withCredentials: false,\n                  mimeType: undefined,\n                  username: '',\n                  password: ''\n                }, options);\n              } else {\n                callback(new Error('No options or target URL is provided.'));\n              }\n\n              if (_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(options.url) === false) {\n                callback(new Error('No target URL is provided.'));\n              }\n\n              options.username = String(options.username);\n              options.password = String(options.password);\n              options.method = options.method.toUpperCase();\n\n              if (options.method !== 'POST' && options.method !== 'PUT') {\n                options.data = undefined;\n              } // console.log(JSON.stringify(options));\n\n\n              function xError() {\n                var crossDomain = xhr.status === 0 ? '. Make sure you have permission if this is a cross-domain request.' : '';\n                err = new Error('The request returned status: ' + xhr.status + crossDomain); // console.log(xhr);\n\n                callback(err, xhr);\n              }\n\n              if (hasCallback) {\n                if (isXDR) {\n                  // IE9\n                  xhr.onload = function () {\n                    callback(null, xhr);\n                  };\n\n                  xhr.onerror = xError;\n                } else {\n                  xhr.onreadystatechange = function () {\n                    if (xhr.readyState === fetch.XHR_READY_STATE.DONE) {\n                      if (xhr.status === 200) {\n                        callback(null, xhr);\n                      } else {\n                        xError();\n                      }\n                    }\n                  };\n                }\n\n                if (_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber(options.timeout) && options.timeout > 0) {\n                  xhr.timeout = options.timeout;\n\n                  xhr.ontimeout = function () {\n                    // xhr.abort();\n                    err = new Error('The request had timed out.');\n                    callback(err, xhr);\n                  };\n                }\n              } // console.log(options);\n\n\n              xhr.open(options.method, options.url, options.async, options.username, options.password); // if this is XDomainRequest, it doesn't support setting custom headers;\n              // or overriding the mime type.\n\n              if (!isXDR) {\n                if (_utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(options.headers)) {\n                  // xhr.setRequestHeader() method should be called after open(), but\n                  // before send().\n                  Object.keys(options.headers).forEach(function (key) {\n                    var value = options.headers[key];\n                    xhr.setRequestHeader(key, value);\n                  });\n                } // xhr.overrideMimeType() method must be called before send().\n\n\n                if (options.mimeType) {\n                  xhr.overrideMimeType(options.mimeType);\n                }\n              }\n\n              xhr.send(options.data);\n            }\n            /**\n             * Alias of `fetch.xhr()` with request method set to `\"GET\"` by default.\n             * @memberof fetch\n             *\n             * @param {Object} options\n             *        Either the URL string which will set other options to defaults or\n             *        the full options object. See `fetch.xhr()` method options for\n             *        details.\n             * @param {Function} [callback]\n             *        The callback function in the following signature:\n             *        `function (err, xhr) { ... }`\n             *        Note that `xhr` object is always passed regardless of an error.\n             * @returns {void}\n             */\n\n          }, {\n            key: 'get',\n            value: function get(options, callback) {\n              return fetch.xhr(options, callback);\n            }\n            /**\n             * Alias of `fetch.xhr()` with request method set to `\"POST\"` by default.\n             * @memberof fetch\n             *\n             * @param {Object} options\n             *        Either the URL string which will set other options to defaults or\n             *        the full options object. See `fetch.xhr()` method options for\n             *        details.\n             * @param {Function} [callback]\n             *        The callback function in the following signature:\n             *        `function (err, xhr) { ... }`\n             *        Note that `xhr` object is always passed regardless of an error.\n             * @returns {void}\n             */\n\n          }, {\n            key: 'post',\n            value: function post(options, callback) {\n              return _xhr('POST', options, callback);\n            }\n            /**\n             * Alias of `fetch.xhr()` with request method set to `\"PUT\"` by default.\n             * @memberof fetch\n             *\n             * @param {Object} options\n             *        Either the URL string which will set other options to defaults or\n             *        the full options object. See `fetch.xhr()` method options for\n             *        details.\n             * @param {Function} [callback]\n             *        The callback function in the following signature:\n             *        `function (err, xhr) { ... }`\n             *        Note that `xhr` object is always passed regardless of an error.\n             * @returns {void}\n             */\n\n          }, {\n            key: 'put',\n            value: function put(options, callback) {\n              return _xhr('PUT', options, callback);\n            }\n            /**\n             * Alias of `fetch.xhr()` with request method set to `\"DELETE\"` by default.\n             * @memberof fetch\n             *\n             * @param {Object} options\n             *        Either the URL string which will set other options to defaults or\n             *        the full options object. See `fetch.xhr()` method options for\n             *        details.\n             * @param {Function} [callback]\n             *        The callback function in the following signature:\n             *        `function (err, xhr) { ... }`\n             *        Note that `xhr` object is always passed regardless of an error.\n             * @returns {void}\n             */\n\n          }, {\n            key: 'delete',\n            value: function _delete(options, callback) {\n              return _xhr('DELETE', options, callback);\n            }\n          }]);\n\n          return fetch;\n        }();\n        /**\n         *  @private\n         */\n\n\n        function _xhr(method, options, callback) {\n          options = _utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(options) ? {\n            url: options\n          } : options || {};\n          options.method = method;\n          return fetch.xhr(options, callback);\n        }\n        /**\n         * Enumerates `XMLHttpRequest` ready states.\n         * Not to be confused with `script.readyState`.\n         * @memberof fetch\n         *\n         * @enum {Number}\n         */\n\n\n        fetch.XHR_READY_STATE = {\n          /**\n           * `xhr.open()` has not been called yet.\n           * @type {Number}\n           */\n          UNSENT: 0,\n\n          /**\n           * `xhr.send()` has been called.\n           * @type {Number}\n           */\n          OPENED: 1,\n\n          /**\n           * `xhr.send()` has been called, and headers and status are available.\n           * @type {Number}\n           */\n          HEADERS_RECEIVED: 2,\n\n          /**\n           * Downloading; responseText holds partial data.\n           * @type {Number}\n           */\n          LOADING: 3,\n\n          /**\n           * The operation is complete.\n           * @type {Number}\n           */\n          DONE: 4\n        };\n        /* harmony default export */\n\n        __webpack_exports__[\"default\"] = fetch;\n        /***/\n      },\n\n      /***/\n      \"./src/lib/utils.js\":\n      /*!**************************!*\\\n        !*** ./src/lib/utils.js ***!\n        \\**************************/\n\n      /*! exports provided: default */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        \"use strict\";\n\n        __webpack_require__.r(__webpack_exports__);\n\n        var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n          return typeof obj;\n        } : function (obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n\n        var _toString = Object.prototype.toString;\n        /**\n         * Simple utility methods; internally used within Geolocator core;\n         * made publically accessible.\n         * @type {Object}\n         * @readonly\n         */\n\n        var utils = {\n          noop: function noop() {},\n          // ---------------------------\n          // Validation\n          // ---------------------------\n\n          /**\n           * Checks if the type of the given value is `String`.\n           * @memberof utils\n           *\n           * @param {*} value - Value to be checked.\n           * @returns {Boolean}\n           */\n          isString: function isString(value) {\n            return typeof value === 'string';\n          },\n          isStringSet: function isStringSet(value) {\n            return typeof value === 'string' && value.trim().length > 0;\n          },\n\n          /**\n           * Checks if the type of the given value is `Number`.\n           * @memberof utils\n           *\n           * @param {*} value - Value to be checked.\n           * @returns {Boolean}\n           */\n          isNumber: function isNumber(value) {\n            return typeof value === 'number';\n          },\n\n          /**\n           * Checks if the type of the given value is an `Object` or `Function`.\n           * @memberof utils\n           *\n           * @param {*} value - Value to be checked.\n           * @returns {Boolean}\n           */\n          isObject: function isObject(value) {\n            var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n            return Boolean(value) && (type === 'object' || type === 'function');\n          },\n\n          /**\n           * Checks if the type of the given value is `Function`.\n           * @memberof utils\n           *\n           * @param {*} value - Value to be checked.\n           * @returns {Boolean}\n           */\n          isFunction: function isFunction(value) {\n            return typeof value === 'function';\n          },\n\n          /**\n           * Checks if the type of the given value is `Array`.\n           * @memberof utils\n           *\n           * @param {*} value - Value to be checked.\n           * @returns {Boolean}\n           */\n          isArray: function isArray(value) {\n            return Boolean(value) && _toString.call(value) === '[object Array]';\n          },\n\n          /**\n           * Checks if the given object is a non-empty `Array`.\n           * @memberof utils\n           *\n           * @param {*} array - Object to be checked.\n           * @returns {Boolean}\n           */\n          isFilledArray: function isFilledArray(array) {\n            return utils.isArray(array) && array.length > 0;\n          },\n\n          /**\n           * Checks if the given value is a plain `Object`.\n           * @memberof utils\n           *\n           * @param {*} value - Value to be checked.\n           * @returns {Boolean}\n           */\n          isPlainObject: function isPlainObject(value) {\n            return Boolean(value) && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && _toString.call(value) === '[object Object]';\n          },\n\n          /**\n           * Checks if the given value is a `Date`.\n           * @memberof utils\n           *\n           * @param {*} value - Value to be checked.\n           * @returns {Boolean}\n           */\n          isDate: function isDate(value) {\n            return Boolean(value) && _toString.call(value) === '[object Date]';\n          },\n\n          /**\n           * Checks if the given object is a DOM element.\n           * @memberof utils\n           *\n           * @param {Object} object - Object to be checked.\n           * @returns {Boolean}\n           */\n          isElement: function isElement(object) {\n            if (!object) return false;\n            return object instanceof HTMLElement || (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object.nodeType === 1;\n          },\n\n          /**\n           * Checks if the given object is a DOM node.\n           * @memberof utils\n           *\n           * @param {Object} object - Object to be checked.\n           * @returns {Boolean}\n           */\n          isNode: function isNode(object) {\n            if (!object) return false;\n            return object instanceof Node || (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number';\n          },\n\n          /**\n           * Checks if the given object is a jQuery instance.\n           * This will still return `false` if the jQuery instance has no items.\n           * @memberof utils\n           *\n           * @param {Object} object - Object to be checked.\n           * @returns {Boolean}\n           */\n          isJQueryObject: function isJQueryObject(object) {\n            if (!object) return false;\n            return 'jQuery' in window && object instanceof window.jQuery && Boolean(object[0]); // http://api.jquery.com/jquery-2/\n            // || (typeof object === 'object' && Boolean(object.jquery));\n          },\n\n          /**\n           * Checks if the type of the given value is an HTML5 `PositionError`.\n           * @memberof utils\n           *\n           * @param {*} value - Value to be checked.\n           * @returns {Boolean}\n           */\n          isPositionError: function isPositionError(value) {\n            return Boolean(value) && _toString.call(value) === '[object PositionError]';\n          },\n\n          /**\n           * Checks if the given value is an instance of `Error` or HTML5 `PositionError`.\n           * @memberof utils\n           *\n           * @param {*} value - Value to be checked.\n           * @returns {Boolean}\n           */\n          isError: function isError(value) {\n            return value instanceof Error || utils.isPositionError(value);\n          },\n          // ---------------------------\n          // String\n          // ---------------------------\n\n          /**\n           * Removes the query string portion from the given URL string.\n           * @memberof utils\n           *\n           * @param {String} str - String to be processed.\n           * @returns {String} - Returns the rest of the string.\n           */\n          removeQuery: function removeQuery(str) {\n            return str.replace(/\\?.*$/, '');\n          },\n\n          /**\n           * Removes the protocol portion from the given URL string.\n           * @memberof utils\n           *\n           * @param {String} str - String to be processed.\n           * @returns {String} - Returns the rest of the string.\n           */\n          removeProtocol: function removeProtocol(str) {\n            return str.replace(/^(.*:)?\\/\\//, '');\n          },\n\n          /**\n           * Sets the protocol of the given URL.\n           * @memberof utils\n           *\n           * @param {String} url\n           *        The URL to be modified.\n           * @param {Boolean} [https]\n           *        Specifies whether to set the protocol to HTTPS.\n           *        If omitted, current page protocol will be used.\n           *\n           * @returns {String} - The modified URL string.\n           */\n          setProtocol: function setProtocol(url, https) {\n            var p = void 0;\n\n            if (https === undefined || https === null) {\n              p = window.location.protocol;\n            } else {\n              p = https ? 'https:' : 'http:';\n            }\n\n            url = utils.removeProtocol(url);\n            return p + '//' + url;\n          },\n\n          /**\n           * Removes both the leading and trailing dots from the given string.\n           * @memberof utils\n           *\n           * @param {String} str - String to be processed.\n           * @returns {String} - Returns the rest of the string.\n           */\n          trimDots: function trimDots(str) {\n            return str.replace(/^\\.+?(.*?)\\.+?$/g, '$1');\n          },\n\n          /**\n           * URL-Encodes the given string. Note that the encoding is done Google's\n           * way; that is, spaces are replaced with `+` instead of `%20`.\n           * @memberof utils\n           *\n           * @param {String} str - String to be processed.\n           * @returns {String} - Returns the encoded string.\n           */\n          encodeURI: function encodeURI(str) {\n            return encodeURIComponent(str).replace(/%20/g, '+');\n          },\n\n          /**\n           * URL-Decodes the given string. This is the reverse of `utils.encodeURI()`;\n           * so pluses (`+`) are replaced with spaces.\n           * @memberof utils\n           *\n           * @param {String} str - String to be processed.\n           * @returns {String} - Returns the decoded string.\n           */\n          decodeURI: function decodeURI(str) {\n            return decodeURIComponent(str.replace(/\\+/g, '%20'));\n          },\n\n          /**\n           * Converts the given value to string.\n           * `null` and `undefined` converts to empty string.\n           * If value is a function, it's native `toString()` method is used.\n           * Otherwise, value is coerced.\n           * @memberof utils\n           *\n           * @param {*} value - String to be converted.\n           * @returns {String} - Returns the result string.\n           */\n          toString: function toString(value) {\n            if (value === null || value === undefined) return '';\n\n            if (value.toString && utils.isFunction(value.toString)) {\n              return value.toString();\n            }\n\n            return String(value);\n          },\n\n          /**\n           * Generates a random string with the number of characters.\n           * @memberof utils\n           *\n           * @param {Number} [len=1] - Length of the string.\n           * @returns {String} - Returns a random string.\n           */\n          randomString: function randomString(len) {\n            if (!len || !utils.isNumber(len)) len = 1;\n            len = -Math.abs(len);\n            return Math.random().toString(36).slice(len);\n          },\n\n          /**\n           * Gets the abbreviation of the given phrase.\n           * @memberof utils\n           *\n           * @param {String} str\n           *        String to abbreviate.\n           * @param {Object} [options]\n           *        Abbreviation options.\n           *     @param {Boolean} [options.upper=true]\n           *            Whether to convert to upper-case.\n           *     @param {Boolean} [options.dots=true]\n           *            Whether to add dots after each abbreviation.\n           *\n           * @returns {String} - Returns the abbreviation of the given phrase.\n           */\n          abbr: function abbr(str, options) {\n            options = utils.extend({\n              upper: true,\n              dots: true\n            }, options);\n            var d = options.dots ? '.' : '',\n                s = str.match(/(\\b\\w)/gi).join(d) + d;\n            return options.upper ? s.toUpperCase() : s;\n          },\n\n          /**\n           * Builds URI parameters from the given object.\n           * Note: This does not iterate deep objects.\n           * @memberof utils\n           *\n           * @param {Object} obj - Object to be processed.\n           * @param {Object} options - Parameterize options.\n           *     @param {Boolean} [options.encode=true]\n           *            Whether to encode URI components.\n           *     @param {String} [options.operator=\"=\"]\n           *     @param {String} [options.separator=\"&\"]\n           *     @param {Array} [options.include]\n           *            Keys to be included in the output params. If defined,\n           *            `options.exclude` is ignored.\n           *     @param {Array} [options.exclude]\n           *            Keys to be excluded from the output params.\n           *\n           * @returns {String} - URI parameters string.\n           */\n          params: function params(obj, options) {\n            if (!utils.isPlainObject(obj) || Object.keys(obj).length === 0) {\n              return '';\n            }\n\n            options = utils.extend({\n              encode: true,\n              operator: '=',\n              separator: '&',\n              include: undefined,\n              exclude: undefined\n            }, options);\n            var params = [],\n                inc = utils.isArray(options.include) ? options.include : null,\n                exc = !inc && utils.isArray(options.exclude) ? options.exclude : null;\n            utils.forIn(obj, function (value, key) {\n              if ((!inc || inc.indexOf(key) >= 0) && (!exc || exc.indexOf(key) < 0)) {\n                var v = utils.toString(value);\n                v = options.encode ? utils.encodeURI(v) : v;\n                var k = options.encode ? utils.encodeURI(key) : key;\n                params.push(k + options.operator + v);\n              }\n            });\n            return params.join(options.separator);\n          },\n\n          /**\n           * Gets the object from the given object notation string.\n           * @private\n           *\n           * @param {String} notation - Object notation.\n           * @returns {*} - Any existing object.\n           */\n          notateGlobalObj: function notateGlobalObj(notation) {\n            notation = utils.trimDots(notation);\n            var levels = notation.split('.'),\n                o = window;\n\n            if (levels[0] === 'window' || levels[0] === 'document') {\n              levels.shift();\n            }\n\n            levels.forEach(function (note) {\n              o = o[note];\n            });\n            return o;\n          },\n          // ---------------------------\n          // Object\n          // ---------------------------\n\n          /**\n           * Iterates over own properties of an object invoking a callback for each\n           * property.\n           * @memberof utils\n           *\n           * @param {Object} obj\n           *        Object to be processed.\n           * @param {Function} callback\n           *        Callback function with the following signature:\n           *        `function (value, key, object) { ... }`.\n           *        Explicitly returning `false` will exit the iteration early.\n           * @returns {void}\n           */\n          forIn: function forIn(obj, callback) {\n            var k = void 0;\n\n            for (k in obj) {\n              // if (obj.hasOwnProperty(k)) {} // Do this inside callback if needed.\n              if (callback(obj[k], k, obj) === false) break;\n            }\n          },\n\n          /**\n           * Extends the given object with the specified sources.\n           * Right most source overwrites the previous.\n           * NOTE: This is not a full implementation. Use with caution.\n           * @memberof utils\n           *\n           * @param {Object} destination\n           *        Destionation Object that will be extended and holds the default\n           *        values.\n           * @param {...Object} sources\n           *        Source objects to be merged.\n           *\n           * @returns {Object} - Returns the extended object.\n           */\n          extend: function extend(destination) {\n            if (!utils.isObject(destination)) return {};\n            var key = void 0,\n                value = void 0;\n\n            for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n              sources[_key - 1] = arguments[_key];\n            }\n\n            sources.forEach(function (source) {\n              for (key in source) {\n                // eslint-disable-line\n                value = source[key];\n\n                if (utils.isArray(value)) {\n                  destination[key] = value.concat();\n                } else if (utils.isDate(value)) {\n                  destination[key] = new Date(value);\n                } else if (utils.isFunction(value)) {\n                  // should be before object\n                  destination[key] = value;\n                } else if (utils.isObject(value)) {\n                  destination[key] = utils.extend({}, value);\n                } else {\n                  destination[key] = value;\n                }\n              }\n            });\n            return destination;\n          },\n\n          /**\n           * Clones the given object.\n           * NOTE: This is not a full implementation. Use with caution.\n           * @memberof utils\n           *\n           * @param {Object} obj\n           *        Target Object to be cloned.\n           * @param {Object|Array} [options]\n           *        Clone options or array of keys to be cloned.\n           *     @param {Array} [options.keys]\n           *            Keys of the properties to be cloned.\n           *     @param {Boolean} [options.own=true]\n           *            Whether to clone own properties only. This is only effective\n           *            if `keys` is not defined.\n           *\n           * @returns {Object} - Returns the cloned object.\n           */\n          clone: function clone(obj, options) {\n            if (!obj) return {};\n\n            if (utils.isArray(options)) {\n              options = {\n                keys: options\n              };\n            }\n\n            options = utils.extend({\n              keys: null,\n              own: true\n            }, options);\n            var include = void 0,\n                cloned = {};\n            utils.forIn(obj, function (value, key) {\n              include = options.keys ? options.keys.indexOf(key) >= 0 : options.own && obj.hasOwnProperty(key) || !options.own;\n\n              if (include) {\n                if (utils.isObject(value)) {\n                  cloned[key] = utils.clone(value, options);\n                } else {\n                  cloned[key] = value;\n                }\n              }\n            });\n            return cloned;\n          },\n\n          /**\n           *  Maps the values of the given object to a schema to re-structure a new\n           *  object.\n           *  @memberof utils\n           *\n           *  @param {Object} obj\n           *         Original object to be mapped.\n           *  @param {Object} schema\n           *         Schema to be used to map the object.\n           *\n           *  @returns {Object} - Mapped object.\n           */\n          mapToSchema: function mapToSchema(obj, schema) {\n            var mapped = {};\n            utils.forIn(schema, function (value, key) {\n              if (utils.isPlainObject(value)) {\n                mapped[key] = utils.mapToSchema(obj, value);\n              } else {\n                mapped[key] = obj[value];\n              }\n            });\n            return mapped;\n          },\n          // ---------------------------\n          // Misc\n          // ---------------------------\n\n          /**\n           * Safely parses the given JSON `String` into an `Object`.\n           * The only difference from `JSON.parse()` is that this method does not\n           * throw for invalid input. Instead, returns `null`.\n           * @memberof utils\n           *\n           * @param {String} str - JSON string to be parsed\n           * @returns {Object|null} - Returns the parsed `Object` or `null` if the\n           * input is invalid.\n           */\n          safeJsonParse: function safeJsonParse(str) {\n            var o = null;\n\n            try {\n              o = JSON.parse(str);\n            } catch (e) {}\n\n            return o;\n          },\n\n          /**\n           * Gets a timestamp that is seconds or milliseconds since midnight,\n           * January 1, 1970 UTC.\n           * @memberof utils\n           *\n           * @param {Boolean} [seconds=false]\n           *        Specifies whether seconds should be returned instead of\n           *        milliseconds.\n           *\n           * @returns {Number} - Returns seconds or milliseconds since midnight,\n           * January 1, 1970 UTC.\n           */\n          time: function time(seconds) {\n            var ts = Date.now();\n            return seconds ? parseInt(ts / 1000, 10) : ts;\n          }\n        };\n        /* harmony default export */\n\n        __webpack_exports__[\"default\"] = utils;\n        /***/\n      }\n      /******/\n\n    })\n  );\n});","map":null,"metadata":{},"sourceType":"script"}